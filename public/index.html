<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Keel · Corpus</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      margin: 0; padding: 0;
      background: #f0f2f5;
      color: #1a1a2e;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 2px solid #dde1ea;
      padding: 0.7rem 1.5rem;
      flex-shrink: 0;
      background: white;
    }
    h1 { margin: 0; font-size: 1.35rem; color: #1a1a2e; letter-spacing: -0.02em; }
    h1 span { color: #5c6bc0; }
    h2 { margin: 0 0 0.9rem; font-size: 0.95rem; font-weight: 700; color: #333;
         text-transform: uppercase; letter-spacing: 0.06em; }

    /* ── Three-column workspace ── */
    .workspace {
      display: grid;
      grid-template-columns: 255px 1fr 1fr;
      gap: 1rem;
      flex: 1;
      min-height: 0;
      padding: 1rem 1.5rem;
      overflow: hidden;
    }

    .col-sidebar {
      overflow-y: auto;
      min-height: 0;
    }

    .col-corpus, .col-viewer {
      overflow-y: hidden;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }

    /* ── Cards ── */
    .card {
      background: white;
      padding: 1.2rem 1.4rem;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.07);
      margin-bottom: 1rem;
    }

    /* ── Corpus card (fills center column) ── */
    .corpus-card {
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
      margin-bottom: 0;
    }
    .corpus-toolbar {
      display: flex;
      align-items: center;
      gap: 0.7rem;
      margin-bottom: 0.5rem;
      flex-shrink: 0;
    }
    .corpus-title-area { flex: 0 0 auto; }
    .doc-count { font-size: 0.8rem; color: #aaa; font-weight: 400;
                 text-transform: none; letter-spacing: 0; }

    /* ── Search row ── */
    .search-row {
      display: flex;
      gap: 0.4rem;
      flex: 1;
    }
    .search-row input { flex: 1; min-width: 0; }

    /* ── Filter indicator ── */
    .filter-bar {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: #eef0fb;
      border-radius: 6px;
      padding: 0.3rem 0.8rem;
      margin-bottom: 0.5rem;
      font-size: 0.83rem;
      color: #3f51b5;
      flex-shrink: 0;
    }
    .filter-bar .clear-btn {
      background: none; border: none; color: #9fa8da;
      cursor: pointer; padding: 0; font-size: 0.85rem;
      margin-left: auto; line-height: 1;
    }
    .filter-bar .clear-btn:hover { color: #c62828; background: none; }

    /* ── Scrollable doc list ── */
    .doc-list {
      list-style: none;
      padding: 0; margin: 0;
      flex: 1;
      overflow-y: auto;
      min-height: 0;
    }

    /* ── Document cards ── */
    .doc-card {
      padding: 0.75rem 2rem 0.75rem 0;
      border-bottom: 1px solid #f0f2f5;
      position: relative;
    }
    .doc-card:last-child { border-bottom: none; }

    .doc-main { cursor: pointer; margin-bottom: 0.4rem; }
    .doc-main:hover .doc-title { color: #3f51b5; }
    .doc-title {
      font-size: 0.9rem; font-weight: 500; color: #1a1a2e;
      line-height: 1.35;
    }
    .doc-meta { font-size: 0.77rem; color: #aaa; margin-top: 0.1rem; }

    .doc-snippet {
      font-size: 0.82rem; color: #555; line-height: 1.5; margin-top: 0.3rem;
    }
    .doc-snippet mark {
      background: #fff176; color: #1a1a2e; border-radius: 2px; padding: 0 1px;
    }

    /* ── Tags row ── */
    .doc-tags {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.3rem;
      margin-top: 0.35rem;
    }

    .tag-chip {
      display: inline-flex;
      align-items: center;
      background: #e8eaf6; color: #3f51b5;
      border-radius: 12px;
      padding: 0.08rem 0.4rem 0.08rem 0.55rem;
      font-size: 0.75rem; font-weight: 500;
      cursor: pointer; white-space: nowrap;
    }
    .tag-chip:hover { background: #c5cae9; }
    .tag-remove {
      background: none; border: none;
      color: #9fa8da; cursor: pointer;
      padding: 0 0 0 0.15rem;
      font-size: 0.9rem; line-height: 1;
      display: flex; align-items: center;
    }
    .tag-remove:hover { color: #c62828; background: none; }

    .btn-add-tag {
      background: none;
      border: 1px dashed #d1d5db;
      color: #bbb;
      border-radius: 12px;
      padding: 0.06rem 0.55rem;
      font-size: 0.74rem;
      cursor: pointer; line-height: 1.6;
    }
    .btn-add-tag:hover { border-color: #5c6bc0; color: #5c6bc0; background: none; }

    .tag-input-inline {
      border: 1px solid #5c6bc0;
      border-radius: 12px;
      padding: 0.06rem 0.6rem;
      font-size: 0.75rem;
      outline: none;
      width: 110px;
      font-family: inherit;
    }
    .tag-confirm-btn {
      background: #5c6bc0; color: white; border: none;
      border-radius: 10px; padding: 0.05rem 0.5rem;
      font-size: 0.73rem; cursor: pointer;
    }
    .tag-confirm-btn:hover { background: #3f51b5; }
    .tag-cancel-btn {
      background: none; border: none;
      color: #bbb; cursor: pointer; font-size: 0.85rem; line-height: 1;
    }
    .tag-cancel-btn:hover { color: #c62828; background: none; }

    /* ── Delete button (top-right of card) ── */
    .btn-doc-delete {
      position: absolute; top: 0.75rem; right: 0;
      background: none; border: none;
      color: #ddd; cursor: pointer;
      padding: 0.1rem 0.25rem; font-size: 0.9rem;
    }
    .btn-doc-delete:hover { color: #e53935; background: none; }

    /* ── Viewer card ── */
    .viewer-card {
      flex: 1; min-height: 0;
      display: flex; flex-direction: column;
      margin-bottom: 0;
    }
    #viewerContent {
      flex: 1; overflow-y: auto; min-height: 0;
    }
    .viewer-placeholder {
      color: #ccc; text-align: center;
      padding: 4rem 1.5rem; font-size: 0.88rem; line-height: 1.6;
    }
    .viewer-doc-header {
      border-bottom: 1px solid #eef0f5;
      padding-bottom: 0.8rem; margin-bottom: 1rem;
    }
    .viewer-body {
      white-space: pre-wrap; word-break: break-word;
      color: #333; font-size: 0.87rem; line-height: 1.8;
    }
    .viewer-body mark { background: #fff176; border-radius: 2px; padding: 0 2px; }

    /* ── Upload form ── */
    .upload-area {
      border: 2px dashed #c5cae9;
      padding: 1.5rem 1rem;
      text-align: center; border-radius: 8px;
      cursor: pointer; background: #fafbff;
      transition: border-color .2s, background .2s;
    }
    .upload-area:hover, .upload-area.dragover {
      border-color: #5c6bc0; background: #eef0fb;
    }
    .upload-area p { margin: 0.2rem 0; color: #666; font-size: 0.88rem; }
    .upload-area .hint { font-size: 0.78rem; color: #bbb; margin-top: 0.4rem; }
    #fileName { font-weight: 600; color: #5c6bc0; min-height: 1.1rem;
                margin-top: 0.4rem; font-size: 0.85rem; }

    .meta-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.7rem; margin: 0.7rem 0; }
    label { font-size: 0.8rem; color: #666; display: block; margin-bottom: 0.2rem; }

    input[type="text"], input[type="date"], input[type="search"] {
      width: 100%;
      padding: 0.48rem 0.65rem;
      border: 1px solid #dde1ea;
      border-radius: 6px;
      font-size: 0.88rem;
      background: #fafbff;
      font-family: inherit;
      color: #1a1a2e;
    }
    input:focus { outline: 2px solid #5c6bc0; border-color: transparent; }
    #kwicInput:focus, #colloInput:focus { outline: none; border-color: #5c6bc0; }

    button {
      background: #5c6bc0; color: white; border: none;
      padding: 0.58rem 1.2rem; border-radius: 6px;
      cursor: pointer; font-size: 0.88rem; font-weight: 500;
      transition: background .15s; font-family: inherit;
    }
    button:hover { background: #3f51b5; }
    button:disabled { background: #b0bec5; cursor: not-allowed; }
    button.danger { background: #e53935; }
    button.danger:hover { background: #c62828; }
    .btn-sm { padding: 0.38rem 0.85rem; font-size: 0.82rem; }

    #uploadStatus { margin-top: 0.5rem; font-size: 0.85rem; font-weight: 500; }
    .success { color: #2e7d32; }
    .error { color: #c62828; }

    /* ── Collapsible upload card ── */
    details.card > summary {
      list-style: none; cursor: pointer;
      font-size: 0.88rem; font-weight: 700; color: #555;
      text-transform: uppercase; letter-spacing: 0.06em;
      user-select: none; display: flex; align-items: center; gap: 0.4rem;
    }
    details.card > summary::-webkit-details-marker { display: none; }
    details.card > summary .arrow { font-size: 0.68rem; color: #bbb; }
    details.card[open] > summary { margin-bottom: 0.9rem; }

    /* ── Tag browser (sidebar) ── */
    .tag-bar {
      display: flex; align-items: center; gap: 0.45rem;
      padding: 0.28rem 0.4rem; border-radius: 6px;
      cursor: pointer; margin-bottom: 0.18rem;
      transition: background .1s;
    }
    .tag-bar:hover { background: #f4f5f9; }
    .tag-bar.active { background: #eef0fb; }
    .tag-bar-label { font-size: 0.84rem; color: #444; white-space: nowrap; overflow: hidden;
                     text-overflow: ellipsis; flex: 1; min-width: 0; }
    .tag-bar.active .tag-bar-label { color: #3f51b5; font-weight: 600; }
    .tag-bar-count { font-size: 0.72rem; color: #bbb; flex: 0 0 2rem; text-align: right;
                     font-variant-numeric: tabular-nums; }
    .tag-bar-actions { display:flex; gap:0.15rem; opacity:0; transition:opacity .15s; flex-shrink:0; }
    .tag-bar:hover .tag-bar-actions { opacity:1; }
    .tag-bar-actions button { background:none; border:none; cursor:pointer; font-size:0.72rem;
                               color:#aaa; padding:0 0.2rem; line-height:1.5; border-radius:3px; }
    .tag-bar-actions button:hover { color:#555; background:#e8eaf0; }
    .tag-editor-row { display:flex; align-items:center; gap:0.3rem; padding:0.18rem 0.4rem;
                      margin-bottom:0.18rem; }
    .tag-editor-input { flex:1; font-size:0.82rem; padding:0.2rem 0.4rem; border:1px solid #7986cb;
                        border-radius:4px; font-family:inherit; min-width:0; }
    .tag-editor-btn { background:none; border:none; cursor:pointer; font-size:0.8rem;
                      padding:0.1rem 0.3rem; border-radius:3px; }
    .tag-editor-btn.save { color:#388e3c; } .tag-editor-btn.save:hover { background:#e8f5e9; }
    .tag-editor-btn.cancel { color:#aaa; } .tag-editor-btn.cancel:hover { background:#f5f5f5; }

    /* ── Tag categories ── */
    .cat-section { margin-bottom: 0.6rem; }
    .cat-header  { display:flex; align-items:center; gap:0.35rem; padding:0.2rem 0.4rem;
                   border-radius:6px; cursor:pointer; user-select:none;
                   font-size:0.8rem; font-weight:600; color:#555;
                   width:100%; border:none; background:none; text-align:left; font-family:inherit; }
    .cat-header:hover { background:#f4f5f9; }
    .cat-color-dot { width:8px; height:8px; border-radius:50%; flex-shrink:0; }
    .cat-header-label { flex:1; }
    .cat-header-actions { display:flex; gap:0.15rem; opacity:0; transition:opacity .15s; }
    .cat-header:hover .cat-header-actions { opacity:1; }
    .cat-header-actions button { background:none; border:none; cursor:pointer;
                                  font-size:0.72rem; color:#aaa; padding:0 0.2rem;
                                  border-radius:3px; line-height:1.5; }
    .cat-header-actions button:hover { color:#555; background:#e8eaf0; }
    .cat-body { padding-left:0.5rem; }
    .cat-remove-tag { background:none; border:none; cursor:pointer; font-size:0.7rem;
                      color:#ccc; padding:0 0.15rem; flex-shrink:0; line-height:1; }
    .cat-remove-tag:hover { color:#e57373; }
    .cat-add-row { display:flex; align-items:center; gap:0.3rem; padding:0.15rem 0.4rem;
                   margin-top:0.1rem; }
    .cat-add-btn { background:none; border:none; color:#bbb; cursor:pointer;
                   font-size:0.78rem; padding:0; }
    .cat-add-btn:hover { color:#5c6bc0; }
    .cat-add-input { flex:1; font-size:0.8rem; padding:0.18rem 0.35rem; border:1px solid #c5cae9;
                     border-radius:4px; font-family:inherit; min-width:0; }
    .new-cat-row { display:flex; gap:0.3rem; align-items:center; margin-bottom:0.5rem; }
    .new-cat-input { flex:1; font-size:0.82rem; padding:0.2rem 0.4rem; border:1px solid #7986cb;
                     border-radius:4px; font-family:inherit; min-width:0; }
    .new-cat-btn { background:none; border:1px solid #c5cae9; border-radius:4px;
                   font-size:0.78rem; color:#7986cb; cursor:pointer; padding:0.2rem 0.45rem; }
    .new-cat-btn:hover { background:#eef0fb; }
    .cat-editor-back { background:none; border:none; cursor:pointer; font-size:0.82rem;
                       color:#7986cb; padding:0.1rem 0.3rem 0.1rem 0; font-weight:600; }
    .cat-editor-back:hover { text-decoration:underline; }
    .cat-editor-name-input { flex:1; font-size:1rem; font-weight:700; color:#333; border:none;
                              border-bottom:2px solid #c5cae9; background:none; outline:none;
                              padding:0.1rem 0; min-width:0; font-family:inherit; }
    .cat-editor-name-input:focus { border-bottom-color:#7986cb; }
    .cat-tag-chip { display:inline-flex; align-items:center; gap:0.3rem; padding:0.25rem 0.55rem;
                    border-radius:20px; border:2px solid #e8eaf6; cursor:pointer;
                    font-size:0.82rem; color:#555; background:#f9f9fb;
                    transition:background .1s, border-color .1s; user-select:none; }
    .cat-tag-chip.in-cat { background:#eef0fb; border-color:#7986cb; color:#3f51b5; font-weight:600; }
    .cat-tag-chip:hover { border-color:#9fa8da; }

    /* ── Inline markup (==highlight== and #tag in viewer) ── */
    mark.inline-hl { background: #fff9c4; border-radius: 2px; padding: 0 2px; }

    /* ── Annotation highlights (DB-backed, coloured by tag) ── */
    .ann-hl {
      border-radius: 2px; padding: 0 1px;
      cursor: help; transition: filter 0.1s;
    }
    .ann-hl:hover { filter: brightness(0.88); }

    /* ── Annotation list (below document body) ── */
    .ann-list {
      margin-top: 1.8rem;
      border-top: 1px solid #eef0f5;
      padding-top: 1rem;
    }
    .ann-list-title {
      font-size: 0.74rem; font-weight: 700; color: #aaa;
      text-transform: uppercase; letter-spacing: 0.07em; margin-bottom: 0.6rem;
    }
    .ann-item {
      padding: 0.45rem 0.7rem;
      border-radius: 0 6px 6px 0;
      margin-bottom: 0.45rem;
      background: #fafbff;
    }
    .ann-item-tag {
      display: inline-block; border-radius: 10px;
      padding: 0.04rem 0.5rem; font-size: 0.73rem; font-weight: 600;
      color: #333; margin-bottom: 0.25rem;
    }
    .ann-item-passage {
      font-size: 0.82rem; color: #555; font-style: italic; line-height: 1.55;
    }
    .ann-item-note { font-size: 0.81rem; color: #333; margin-top: 0.2rem; line-height: 1.5; }

    /* ── Sort select ── */
    .sort-select {
      padding: 0.4rem 0.5rem;
      border: 1px solid #dde1ea;
      border-radius: 6px;
      font-size: 0.8rem;
      font-family: inherit;
      color: #555;
      background: #fafbff;
      cursor: pointer;
      flex-shrink: 0;
    }
    .sort-select:focus { outline: 2px solid #5c6bc0; border-color: transparent; }

    /* ── Annotation edit button ── */
    .btn-edit-ann {
      float: right; margin-left: 0.4rem;
      background: none; border: none; color: #ccc;
      cursor: pointer; padding: 0 0.2rem; font-size: 0.88rem; line-height: 1;
    }
    .btn-edit-ann:hover { color: #5c6bc0; background: none; }

    /* ── Active document in corpus list ── */
    .doc-card.doc-active { background: #eeefff; }

    /* ── Viewer / Research tabs ── */
    .tab-btn {
      padding: 0.28rem 0.8rem;
      border: 1px solid #dde1ea;
      border-radius: 6px;
      font-size: 0.8rem;
      cursor: pointer;
      background: white;
      color: #888;
      font-family: inherit;
      font-weight: 500;
      transition: background .12s, color .12s;
    }
    .tab-btn.tab-active { background: #5c6bc0; color: white; border-color: #5c6bc0; }
    .tab-btn:hover:not(.tab-active) { background: #eef0fb; color: #3f51b5; border-color: #c5cae9; }

    /* ── Analysis sub-tabs ── */
    .ana-tab {
      padding: 0.16rem 0.55rem;
      border: 1px solid #dde1ea;
      border-radius: 4px;
      font-size: 0.75rem;
      cursor: pointer;
      background: white;
      color: #888;
      font-family: inherit;
    }
    .ana-tab.ana-active { background: #eef0fb; color: #3f51b5; border-color: #9fa8da; font-weight: 600; }
    .ana-tab:hover:not(.ana-active) { background: #f5f6ff; }

    /* ── Frequency mode toggle ── */
    .freq-mode-btn {
      padding: 0.28rem 0.6rem;
      border: none; font-size: 0.76rem; cursor: pointer;
      background: white; color: #888; font-family: inherit;
    }
    .freq-mode-btn.active { background: #5c6bc0; color: white; }
    .freq-mode-btn:hover:not(.active) { background: #eef0fb; color: #3f51b5; }

    /* ── Frequency chip selector ── */
    .freq-chip {
      display: inline-flex; align-items: center; gap: 0.25rem;
      padding: 0.22rem 0.5rem; border-radius: 20px;
      border: 2px solid #e8eaf6; cursor: pointer;
      font-size: 0.79rem; color: #666; background: #f9f9fb;
      transition: background .12s, border-color .12s; user-select: none;
    }
    .freq-chip.selected {
      border-color: var(--chip-color, #7986cb);
      background: color-mix(in srgb, var(--chip-color, #7986cb) 12%, white);
      color: var(--chip-color, #7986cb); font-weight: 600;
    }
    .freq-chip:hover:not(.selected) { border-color: #9fa8da; }

    /* ── KWIC concordance ── */
    .kwic-row {
      display: flex; border-bottom: 1px solid #f5f5f5;
      padding: 0.12rem 0; align-items: baseline; cursor: pointer;
    }
    .kwic-row:hover { background: #fafbff; }
    .kwic-left  { text-align: right; color: #bbb; flex: 0 0 36%; overflow: hidden;
                  white-space: nowrap; text-overflow: ellipsis; direction: rtl;
                  padding-right: 0.3rem; font-size: 0.78rem; font-family: monospace; }
    .kwic-match { font-weight: 700; color: #3f51b5; white-space: nowrap; flex-shrink: 0;
                  font-size: 0.78rem; font-family: monospace; }
    .kwic-right { color: #bbb; flex: 1; overflow: hidden; white-space: nowrap;
                  text-overflow: ellipsis; padding-left: 0.3rem;
                  font-size: 0.78rem; font-family: monospace; }
    .kwic-meta  { font-size: 0.67rem; color: #ccc; flex-shrink: 0; white-space: nowrap;
                  padding-left: 0.45rem; }
  </style>
</head>
<body>

<header>
  <h1>Keel <span>· Corpus</span></h1>
  <div style="display:flex; align-items:center; gap:0.8rem">
    <span id="syncStatusBadge" style="font-size:0.78rem; color:#aaa"></span>
    <button id="syncBtn" style="padding:0.38rem 0.85rem; font-size:0.8rem; display:none"
            onclick="triggerSync()">↑↓ Sync</button>
    <a href="/api/documents" target="_blank"
       style="font-size:0.8rem; color:#aaa; text-decoration:none">API ↗</a>
  </div>
</header>

<div class="workspace">

<!-- ── Left sidebar ── -->
<div class="col-sidebar">

  <!-- Upload (collapsed by default) -->
  <details class="card">
    <summary><span class="arrow">▸</span> Upload Documents</summary>
    <form id="uploadForm">
      <div class="upload-area" id="dropZone">
        <p>Drop a <strong>folder</strong> or click to select files</p>
        <p class="hint">.md and .txt files · drag a whole folder to import in bulk</p>
        <input type="file" id="fileInput" name="files" style="display:none"
               multiple accept=".md,.txt,text/plain,text/markdown">
        <div id="fileName"></div>
      </div>

      <div class="meta-grid">
        <div>
          <label>Author</label>
          <input type="text" name="author" placeholder="e.g. Eduard Hanslick">
        </div>
        <div>
          <label>Date</label>
          <input type="date" name="publication_date">
        </div>
      </div>

      <label>Tags <span style="color:#ccc; font-size:0.77rem">(comma-separated)</span></label>
      <input type="text" name="tags" placeholder="music, romanticism" style="margin-bottom:0.8rem">

      <button type="submit" id="submitBtn">Upload</button>
      <div id="uploadStatus"></div>
    </form>
    <div style="display:flex; gap:0.4rem; margin-top:0.65rem; padding-top:0.65rem;
                border-top:1px solid #eef0f5">
      <button id="exportBtn" class="btn-sm"
              style="flex:1; font-size:0.75rem; background:#f3f4f6; color:#666;
                     border:1px solid #ddd; opacity:0.85">
        Export .zip
      </button>
      <button id="deleteAllBtn" class="danger btn-sm"
              style="flex:1; font-size:0.75rem; opacity:0.75">
        Delete all
      </button>
    </div>
  </details>

  <!-- Tag / category browser -->
  <div class="card">
    <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:0.9rem">
      <h2 style="margin:0">Tags</h2>
      <button class="new-cat-btn" id="newCatToggleBtn" onclick="toggleNewCatForm()">+ Category</button>
    </div>
    <div id="newCatForm" style="display:none">
      <div class="new-cat-row">
        <input id="newCatInput" class="new-cat-input" type="text" placeholder="Category name…"
               onkeydown="if(event.key==='Enter'){event.preventDefault();createCategory();}
                          else if(event.key==='Escape'){toggleNewCatForm();}">
        <button class="new-cat-btn" onclick="createCategory()">✓</button>
        <button class="new-cat-btn" style="color:#aaa" onclick="toggleNewCatForm()">✕</button>
      </div>
    </div>
    <div id="tagList">
      <span style="color:#ccc; font-size:0.85rem">Loading…</span>
    </div>
  </div>

</div><!-- /col-sidebar -->

<!-- ── Center: corpus library ── -->
<div class="col-corpus">

<!-- Category editor (shown instead of library when a category is selected) -->
<div id="catEditorPanel" class="card corpus-card" style="display:none; overflow:hidden">
  <div class="corpus-toolbar" style="flex-shrink:0">
    <div class="corpus-title-area">
      <button class="cat-editor-back" onclick="closeCategoryEditor()">← Library</button>
    </div>
    <div style="display:flex; align-items:center; gap:0.5rem; flex:1; min-width:0">
      <input type="color" id="catEditorColor" title="Category colour"
             style="width:28px; height:28px; border:none; background:none; cursor:pointer; padding:0; border-radius:50%; flex-shrink:0"
             oninput="document.getElementById('catEditorDot').style.background=this.value"
             onchange="saveCategoryColor()">
      <span id="catEditorDot" class="cat-color-dot" style="width:10px;height:10px;flex-shrink:0"></span>
      <input id="catEditorName" class="cat-editor-name-input" type="text" placeholder="Category name"
             onkeydown="if(event.key==='Enter')this.blur()"
             onblur="saveCategoryName()">
    </div>
    <button class="btn-sm" style="color:#e57373; border-color:#e57373" onclick="deleteCategoryFromEditor()">Delete</button>
  </div>
  <div style="flex:1; overflow-y:auto; padding-top:0.5rem">
    <p style="font-size:0.78rem; color:#aaa; margin:0 0 0.6rem">Check tags to include in this category:</p>
    <div id="catEditorTagList" style="display:flex; flex-wrap:wrap; gap:0.35rem"></div>
  </div>
</div>

<div id="libraryPanel" class="card corpus-card">

  <div class="corpus-toolbar">
    <div class="corpus-title-area">
      <h2 style="margin:0">Library</h2>
      <div class="doc-count" id="docCount"></div>
    </div>
    <div class="search-row">
      <input type="search" id="searchInput" placeholder="Search documents…">
      <span style="color:#ccc; font-size:0.72rem; flex-shrink:0; align-self:center; white-space:nowrap">Year</span>
      <input type="text" id="dateFrom" placeholder="from"
             style="width:50px; flex:0 0 auto; padding:0.48rem 0.4rem; text-align:center">
      <span style="color:#ccc; align-self:center; flex-shrink:0">–</span>
      <input type="text" id="dateTo" placeholder="to"
             style="width:44px; flex:0 0 auto; padding:0.48rem 0.4rem; text-align:center">
      <button id="searchBtn" class="btn-sm">Search</button>
    </div>
    <select id="sortSelect" class="sort-select" title="Sort order">
      <option value="date-asc">Date ↑</option>
      <option value="date-desc">Date ↓</option>
      <option value="alpha-asc">A → Z</option>
      <option value="alpha-desc">Z → A</option>
    </select>
  </div>

  <!-- Boolean tag filter row -->
  <div style="display:flex; gap:0.4rem; margin-bottom:0.35rem; flex-shrink:0">
    <input type="text" id="boolFilterInput"
           placeholder="Tag filter: #tag1 AND #tag2 NOT #tag3…"
           style="flex:1; font-size:0.82rem">
    <button id="boolFilterBtn" class="btn-sm">Filter</button>
  </div>

  <!-- Active filter indicator (hidden by default) -->
  <div class="filter-bar" id="filterBar" style="display:none">
    <span id="filterLabel"></span>
    <button class="clear-btn" onclick="clearFilter()" title="Clear filter">× clear</button>
  </div>

  <!-- Document list -->
  <ul class="doc-list" id="docList">
    <li style="padding:0.5rem 0; color:#ccc; font-size:0.88rem">Loading…</li>
  </ul>

</div>
</div><!-- /col-corpus -->

<!-- ── Right: document viewer / analysis ── -->
<div class="col-viewer">
<div class="card viewer-card">

  <!-- Tab bar -->
  <div style="flex-shrink:0; display:flex; align-items:center; justify-content:space-between; margin-bottom:0.55rem">
    <div style="display:flex; gap:0.25rem">
      <button id="tabDocument" class="tab-btn tab-active" onclick="switchTab('document')">Document</button>
      <button id="tabAnalysis" class="tab-btn" onclick="switchTab('analysis')">Research</button>
    </div>
    <label id="annotationsOnlyWrap" style="font-size:0.78rem; color:#888; display:flex;
                  align-items:center; gap:0.35rem; cursor:pointer; font-weight:normal">
      <input type="checkbox" id="annotationsOnlyToggle"> Annotations only
    </label>
  </div>

  <!-- Pending annotation panel -->
  <div id="pending-annotation" hidden style="flex-shrink:0; margin-bottom:0.5rem">
    <div style="background:#f5f6ff; border:1px solid #c5cae9; border-radius:8px;
                padding:0.55rem 0.8rem; display:flex; flex-direction:column; gap:0.35rem">
      <div id="pending-ann-title"
           style="font-size:0.72rem; font-weight:700; color:#5c6bc0;
                  letter-spacing:0.04em; text-transform:uppercase">New annotation</div>
      <div id="pending-passage-preview"
           style="font-size:0.79rem; color:#555; font-style:italic;
                  white-space:nowrap; overflow:hidden; text-overflow:ellipsis"></div>
      <div style="display:flex; gap:0.4rem; align-items:center; flex-wrap:wrap">
        <input id="pending-tag" type="text" placeholder="tag (required)"
               style="flex:1; min-width:70px; padding:0.22rem 0.45rem;
                      border:1px solid #c5cae9; border-radius:5px;
                      font-size:0.8rem; font-family:inherit">
        <input id="pending-note" type="text" placeholder="note (optional)"
               style="flex:2; min-width:100px; padding:0.22rem 0.45rem;
                      border:1px solid #dde1ea; border-radius:5px;
                      font-size:0.8rem; font-family:inherit">
        <button id="pending-save"
                style="background:#5c6bc0; color:white; border:none; border-radius:5px;
                       padding:0.25rem 0.75rem; font-size:0.8rem; cursor:pointer;
                       font-family:inherit">Annotate</button>
        <button id="pending-cancel"
                style="background:none; border:none; color:#bbb; cursor:pointer;
                       font-size:1rem; padding:0 0.1rem; line-height:1">✕</button>
      </div>
    </div>
  </div>

  <!-- Document viewer -->
  <div id="viewerContent">
    <p class="viewer-placeholder">Click a document title to read it here.</p>
  </div>

  <!-- Analysis panel (hidden until Research tab is active) -->
  <div id="analysisPanel" style="display:none; flex-direction:column; flex:1; min-height:0; overflow:hidden">

    <!-- Sub-tabs -->
    <div style="display:flex; gap:0.25rem; margin-bottom:0.8rem; flex-shrink:0; flex-wrap:wrap">
      <button class="ana-tab ana-active" id="anaTabKwic"     onclick="showAnalysis('kwic')">KWIC</button>
      <button class="ana-tab"            id="anaTabCollo"    onclick="showAnalysis('collo')">Collocates</button>
      <button class="ana-tab"            id="anaTabFreq"     onclick="showAnalysis('freq')">Frequency</button>
      <button class="ana-tab"            id="anaTabCooc"     onclick="showAnalysis('cooc')">Co-occurrence</button>
      <button class="ana-tab"            id="anaTabTimeline" onclick="showAnalysis('timeline')">Timeline</button>
    </div>

    <!-- KWIC concordance -->
    <div id="anaPanelKwic" style="display:flex; flex-direction:column; flex:1; min-height:0">
      <div style="display:flex; gap:0.4rem; margin-bottom:0.6rem; flex-shrink:0">
        <input id="kwicInput" type="text" placeholder="Key word in context…" style="flex:1">
        <button id="kwicBtn" class="btn-sm">Find</button>
      </div>
      <div id="kwicResults" style="flex:1; overflow-y:auto; min-height:0">
        <span style="color:#ccc; font-size:0.83rem">Enter a term to search across the full corpus.</span>
      </div>
    </div>

    <!-- Collocates -->
    <div id="anaPanelCollo" style="display:none; flex-direction:column; flex:1; min-height:0">
      <div style="display:flex; gap:0.4rem; margin-bottom:0.6rem; flex-shrink:0">
        <input id="colloInput" type="text" placeholder="Find collocates of…" style="flex:1">
        <button id="colloBtn" class="btn-sm">Find</button>
      </div>
      <div id="colloResults" style="flex:1; overflow-y:auto; min-height:0">
        <span style="color:#ccc; font-size:0.83rem">Enter a term to see its most frequent neighbours.</span>
      </div>
    </div>

    <!-- Term frequency over time -->
    <div id="anaPanelFreq" style="display:none; flex-direction:column; flex:1; min-height:0">
      <div style="display:flex; gap:0.4rem; margin-bottom:0.35rem; flex-shrink:0; align-items:center">
        <div style="display:flex; border:1px solid #dde1ea; border-radius:6px; overflow:hidden; flex-shrink:0">
          <button id="freqModeTermBtn" class="freq-mode-btn active" onclick="setFreqMode('term')">Term</button>
          <button id="freqModeTagBtn"  class="freq-mode-btn"        onclick="setFreqMode('tag')">#Tag</button>
          <button id="freqModeCatBtn"  class="freq-mode-btn"        onclick="setFreqMode('category')">Category</button>
        </div>
        <input id="freqInput" type="text" placeholder="Term(s) to plot, comma-separated…" style="flex:1">
        <button id="freqClearBtn" title="Clear"
                style="background:none; border:none; color:#ccc; cursor:pointer;
                       font-size:1.05rem; padding:0 0.1rem; line-height:1">×</button>
        <button id="freqBtn" class="btn-sm">Plot</button>
      </div>
      <div id="freqChipArea" style="display:none; flex-wrap:wrap; gap:0.35rem; max-height:110px;
           overflow-y:auto; padding:0.3rem 0 0.45rem; flex-shrink:0"></div>
      <div id="freqResults" style="flex:1; overflow-y:auto; min-height:0">
        <span style="color:#ccc; font-size:0.83rem">Enter a term or select tags/categories to plot frequency per decade.</span>
      </div>
    </div>

    <!-- Tag co-occurrence -->
    <div id="anaPanelCooc" style="display:none; flex:1; overflow-y:auto; min-height:0">
      <div id="coocResults" style="padding-bottom:1rem">
        <span style="color:#ccc; font-size:0.83rem">Loading…</span>
      </div>
    </div>

    <!-- Document timeline -->
    <div id="anaPanelTimeline" style="display:none; flex:1; overflow-y:auto; min-height:0">
      <div id="timelineResults" style="padding-bottom:1rem">
        <span style="color:#ccc; font-size:0.83rem">Loading…</span>
      </div>
    </div>

  </div><!-- /analysisPanel -->

</div>
</div><!-- /col-viewer -->

</div><!-- /workspace -->

<script>
// ── Utilities ─────────────────────────────────────────────────────────────────

function escapeHtml(str) {
  return String(str ?? '')
    .replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}

function parseTags(raw) {
  try { return JSON.parse(raw || '[]'); } catch { return []; }
}

// ── State ─────────────────────────────────────────────────────────────────────

let activeTagFilter      = null;
let activeBoolFilter     = null;   // parsed boolean tag expression [{op,tag},…]
let activeSearchQuery    = null;
let activeDateFrom       = '';     // year filter lower bound (e.g. '1800')
let activeDateTo         = '';     // year filter upper bound (e.g. '1850')
let categoriesData       = [];     // [{id, name, color, tags:[...]}]
let currentDocId         = null;   // document currently open in the viewer
let currentDocContent    = null;   // raw content string of that document
let showAnnotationsOnly  = false;
let currentSort          = 'date-asc';
let reselectAnnId        = null;   // annotation being re-selected (Option C)
let reselectTag          = '';
let reselectNote         = '';
let activeViewerTab      = 'document';   // 'document' | 'analysis'
let activeAnalysisTab    = 'kwic';       // 'kwic' | 'cooc' | 'timeline'
let coocLoaded           = false;
let timelineLoaded       = false;
let timelineDocs         = {};

// ── File selection & upload ───────────────────────────────────────────────────

const dropZone   = document.getElementById('dropZone');
const fileInput  = document.getElementById('fileInput');
const fileNameEl = document.getElementById('fileName');
let selectedFiles = [];

function isAllowed(name) { return name.endsWith('.md') || name.endsWith('.txt'); }

async function readFilesFromEntry(entry, out = []) {
  if (entry.isFile) {
    if (isAllowed(entry.name))
      await new Promise((res, rej) => entry.file(f => { out.push(f); res(); }, rej));
  } else if (entry.isDirectory) {
    const reader = entry.createReader();
    let batch;
    do {
      batch = await new Promise((res, rej) => reader.readEntries(res, rej));
      for (const e of batch) await readFilesFromEntry(e, out);
    } while (batch.length > 0);
  }
  return out;
}

dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', async e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  const items = [...(e.dataTransfer?.items ?? [])];
  const files = [];
  for (const item of items) {
    const entry = item.webkitGetAsEntry?.();
    if (entry) await readFilesFromEntry(entry, files);
  }
  if (files.length) { selectedFiles = files; updateFileName(); }
});
fileInput.addEventListener('change', () => {
  selectedFiles = [...fileInput.files].filter(f => isAllowed(f.name));
  updateFileName();
});

function updateFileName() {
  fileNameEl.textContent = !selectedFiles.length ? '' :
    selectedFiles.length === 1 ? selectedFiles[0].name :
    `${selectedFiles.length} files selected`;
}

document.getElementById('uploadForm').addEventListener('submit', async e => {
  e.preventDefault();
  const btn    = document.getElementById('submitBtn');
  const status = document.getElementById('uploadStatus');
  const files  = selectedFiles.length ? selectedFiles
    : [...(fileInput.files ?? [])].filter(f => isAllowed(f.name));

  if (!files.length) {
    status.innerHTML = '<span class="error">✗ No .md or .txt files selected.</span>';
    return;
  }

  btn.disabled = true; btn.textContent = 'Uploading…'; status.textContent = '';

  const form = new FormData(document.getElementById('uploadForm'));
  form.delete('files');
  for (const f of files) form.append('files', f);
  const tagsRaw = form.get('tags');
  if (tagsRaw) form.set('tags',
    JSON.stringify(String(tagsRaw).split(',').map(t => t.trim()).filter(Boolean)));

  try {
    const res  = await fetch('/api/upload', { method: 'POST', body: form });
    const data = await res.json();
    if (res.ok) {
      const count   = Array.isArray(data) ? data.length : 1;
      const hlCount = Array.isArray(data)
        ? data.reduce((s, d) => s + (d.inline_annotations || 0), 0)
        : (data.inline_annotations || 0);
      const hlNote  = hlCount ? ` · ${hlCount} note${hlCount !== 1 ? 's' : ''} extracted` : '';
      status.innerHTML =
        `<span class="success">✓ ${count} document${count > 1 ? 's' : ''} added${hlNote}.</span>`;
      document.getElementById('uploadForm').reset();
      fileNameEl.textContent = ''; selectedFiles = [];
      refreshCorpus();
    } else { throw new Error(data.error || 'Upload failed'); }
  } catch (err) {
    status.innerHTML = `<span class="error">✗ ${escapeHtml(err.message)}</span>`;
  } finally { btn.disabled = false; btn.textContent = 'Upload'; }
});

// ── Corpus view ───────────────────────────────────────────────────────────────

async function refreshCorpus() {
  coocLoaded = false;
  timelineLoaded = false;
  await Promise.all([loadDocuments(), loadTagSummary()]);
}

async function loadDocuments() {
  const list = document.getElementById('docList');
  list.innerHTML = '<li style="padding:0.5rem 0; color:#ccc; font-size:0.88rem">Loading…</li>';
  try {
    if (activeSearchQuery) { await loadSearchResults(activeSearchQuery); return; }

    const res  = await fetch('/api/documents');
    let docs   = await res.json();

    if (activeTagFilter) {
      docs = docs.filter(doc => parseTags(doc.tags).includes(activeTagFilter));
    } else if (activeBoolFilter) {
      docs = applyBoolFilter(docs, activeBoolFilter);
    }

    renderDocList(docs, false);
  } catch (err) {
    list.innerHTML =
      `<li class="error" style="padding:0.5rem 0">Failed to load: ${escapeHtml(err.message)}</li>`;
  }
}

async function loadSearchResults(query) {
  const list = document.getElementById('docList');
  try {
    const res  = await fetch('/api/search?q=' + encodeURIComponent(query));
    const rows = await res.json();
    renderDocList(rows, true);
  } catch (err) {
    list.innerHTML =
      `<li class="error" style="padding:0.5rem 0">Search failed: ${escapeHtml(err.message)}</li>`;
  }
}

function renderSnippet(raw) {
  return escapeHtml(raw || '').replace(/\*\*(.+?)\*\*/g, '<mark>$1</mark>');
}

function sortDocs(docs) {
  const [field, dir] = currentSort.split('-');
  return [...docs].sort((a, b) => {
    const va = field === 'date' ? (a.publication_date || '') : (a.title || '').toLowerCase();
    const vb = field === 'date' ? (b.publication_date || '') : (b.title || '').toLowerCase();
    const cmp = va < vb ? -1 : va > vb ? 1 : 0;
    return dir === 'asc' ? cmp : -cmp;
  });
}

function renderDocList(docs, hasSnippets) {
  const list    = document.getElementById('docList');
  const countEl = document.getElementById('docCount');

  // Apply client-side date range filter
  if (activeDateFrom || activeDateTo) {
    docs = docs.filter(doc => {
      const year = String(doc.publication_date || '').trim().slice(0, 4);
      if (!year || year.length < 4) return false;
      if (activeDateFrom && year < activeDateFrom) return false;
      if (activeDateTo   && year > activeDateTo)   return false;
      return true;
    });
  }

  if (!docs.length) {
    const msg = activeSearchQuery ? 'No documents match your search.'
      : activeTagFilter  ? `No documents tagged #${escapeHtml(activeTagFilter)}.`
      : activeBoolFilter ? 'No documents match this tag filter.'
      : 'Upload documents to get started.';
    countEl.textContent = (activeSearchQuery || activeTagFilter || activeBoolFilter) ? 'No matches' : 'Empty';
    list.innerHTML =
      `<li style="padding:1.5rem 0; color:#ccc; font-size:0.88rem; text-align:center">${msg}</li>`;
    return;
  }

  countEl.textContent = `${docs.length} document${docs.length !== 1 ? 's' : ''}`;
  list.innerHTML = sortDocs(docs).map(doc => renderDocCard(doc, hasSnippets ? doc.snippet : null)).join('');
}

function renderDocCard(doc, snippet) {
  const tags    = parseTags(doc.tags);
  const docId   = doc.id;

  const tagChips = tags.map(tag => `
    <span class="tag-chip" data-tag="${escapeHtml(tag)}" data-doc-id="${docId}">
      <span class="tag-chip-label">#${escapeHtml(tag)}</span>
      <button class="tag-remove" data-remove-tag="${escapeHtml(tag)}"
              data-doc-id="${docId}" title="Remove tag">×</button>
    </span>`).join('');

  const snippetHtml = snippet
    ? `<div class="doc-snippet">${doc.from_annotation ? `&ldquo;${renderSnippet(snippet)}&rdquo;` : renderSnippet(snippet)}</div>` : '';

  return `
    <li class="doc-card${docId === currentDocId ? ' doc-active' : ''}" id="doc-${docId}" data-doc-id="${docId}">
      <div class="doc-main" data-view-doc="${docId}">
        <div class="doc-title">${escapeHtml(doc.title || 'Untitled')}</div>
        <div class="doc-meta">${escapeHtml(doc.author || '—')} · ${escapeHtml(doc.publication_date || '?')}</div>
        ${snippetHtml}
      </div>
      <div class="doc-tags">
        ${tagChips}
        <button class="btn-add-tag" data-show-tag-input="${docId}">+ tag</button>
        <input class="tag-input-inline" id="tag-input-${docId}"
               placeholder="type tag, press Enter" style="display:none"
               data-doc-id="${docId}">
        <button class="tag-confirm-btn" id="tag-save-${docId}"
                style="display:none" data-confirm-tag="${docId}">✓</button>
        <button class="tag-cancel-btn" id="tag-cancel-${docId}"
                style="display:none" data-cancel-tag="${docId}">✕</button>
      </div>
      <button class="btn-doc-delete" data-delete-doc="${docId}" title="Delete document">✕</button>
    </li>`;
}

// ── Event delegation on doc list ──────────────────────────────────────────────

document.getElementById('docList').addEventListener('click', async e => {
  // Remove a tag chip (× button)
  const removeBtn = e.target.closest('[data-remove-tag]');
  if (removeBtn) {
    e.stopPropagation();
    await removeTag(removeBtn.dataset.docId, removeBtn.dataset.removeTag);
    return;
  }

  // Click tag chip label → browse by tag
  const tagChip = e.target.closest('.tag-chip');
  if (tagChip && !e.target.closest('[data-remove-tag]')) {
    browseTag(tagChip.dataset.tag);
    return;
  }

  // Click doc title/meta → view document
  const viewEl = e.target.closest('[data-view-doc]');
  if (viewEl) { viewDocument(viewEl.dataset.viewDoc); return; }

  // Show tag input
  const addTagBtn = e.target.closest('[data-show-tag-input]');
  if (addTagBtn) { showTagInput(addTagBtn.dataset.showTagInput); return; }

  // Confirm new tag
  const confirmBtn = e.target.closest('[data-confirm-tag]');
  if (confirmBtn) { await commitTag(confirmBtn.dataset.confirmTag); return; }

  // Cancel tag input
  const cancelBtn = e.target.closest('[data-cancel-tag]');
  if (cancelBtn) { hideTagInput(cancelBtn.dataset.cancelTag); return; }

  // Delete document
  const deleteBtn = e.target.closest('[data-delete-doc]');
  if (deleteBtn) { await deleteDoc(deleteBtn.dataset.deleteDoc); return; }
});

document.getElementById('docList').addEventListener('keydown', e => {
  const input = e.target.closest('.tag-input-inline');
  if (!input) return;
  const docId = input.dataset.docId;
  if (e.key === 'Enter') { e.preventDefault(); commitTag(docId); }
  if (e.key === 'Escape') hideTagInput(docId);
});

// ── Tag editing ───────────────────────────────────────────────────────────────

function showTagInput(docId) {
  const input      = document.getElementById('tag-input-' + docId);
  const saveBtn    = document.getElementById('tag-save-' + docId);
  const cancelBtn  = document.getElementById('tag-cancel-' + docId);
  const addTagBtn  = document.querySelector(`[data-show-tag-input="${docId}"]`);
  if (!input) return;
  if (addTagBtn)  addTagBtn.style.display  = 'none';
  input.style.display    = 'inline-block';
  saveBtn.style.display  = 'inline-block';
  cancelBtn.style.display = 'inline-block';
  input.focus();
}

function hideTagInput(docId) {
  const input     = document.getElementById('tag-input-' + docId);
  const saveBtn   = document.getElementById('tag-save-' + docId);
  const cancelBtn = document.getElementById('tag-cancel-' + docId);
  const addTagBtn = document.querySelector(`[data-show-tag-input="${docId}"]`);
  if (!input) return;
  input.value = ''; input.style.display = 'none';
  if (saveBtn)   saveBtn.style.display   = 'none';
  if (cancelBtn) cancelBtn.style.display = 'none';
  if (addTagBtn) addTagBtn.style.display = '';
}

async function commitTag(docId) {
  const input = document.getElementById('tag-input-' + docId);
  if (!input) return;
  const raw = input.value.trim();
  if (!raw) { hideTagInput(docId); return; }
  // Normalise: lowercase, spaces → hyphens
  const tag = raw.toLowerCase().replace(/\s+/g, '-');
  hideTagInput(docId);
  await addTag(docId, tag);
}

async function addTag(docId, tag) {
  try {
    const doc  = await fetch('/api/documents/' + docId).then(r => r.json());
    const tags = parseTags(doc.tags);
    if (tags.includes(tag)) return;
    await updateDocTags(docId, [...tags, tag]);
  } catch (err) { alert('Could not add tag: ' + err.message); }
}

async function removeTag(docId, tag) {
  try {
    // 1. Compute new tag list and patch the document
    const doc  = await fetch('/api/documents/' + docId).then(r => r.json());
    const tags = parseTags(doc.tags).filter(t => t !== tag);
    const r = await fetch('/api/documents/' + docId, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ tags }),
    });
    if (!r.ok) { const e = await r.json(); throw new Error(e.error || 'Update failed'); }

    // 2. Delete orphan inline annotations for the removed tag
    const anns = await fetch('/api/documents/' + docId + '/annotations').then(r => r.json());
    const orphans = anns.filter(a =>
      a.author_id === 'inline' &&
      (a.tag === tag || (a.tag == null && tags.length === 0))
    );
    const results = await Promise.allSettled(
      orphans.map(a => fetch('/api/annotations/' + a.id, { method: 'DELETE' })
        .then(r => { if (!r.ok) throw new Error('Delete failed for ' + a.id); })
      )
    );
    const failures = results.filter(r => r.status === 'rejected');
    if (failures.length) console.warn('Some annotation deletes failed:', failures);

    // 3. Refresh everything now that all mutations are done
    if (currentDocId === docId) await viewDocument(docId);
    await refreshCorpus();
    loadTagSummary();
  } catch (err) { alert('Could not remove tag: ' + err.message); }
}

async function updateDocTags(docId, tags) {
  const r = await fetch('/api/documents/' + docId, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ tags }),
  });
  if (!r.ok) { const e = await r.json(); throw new Error(e.error || 'Update failed'); }
  await refreshCorpus();
}

// ── Search ────────────────────────────────────────────────────────────────────

async function doSearch() {
  const q = document.getElementById('searchInput').value.trim();
  if (!q) { clearFilter(); return; }
  activeSearchQuery = q;
  activeTagFilter   = null;
  activeBoolFilter  = null;
  document.getElementById('boolFilterInput').value = '';
  updateFilterBar();
  await loadDocuments();
}

function clearFilter() {
  activeSearchQuery = null;
  activeTagFilter   = null;
  activeBoolFilter  = null;
  activeDateFrom    = '';
  activeDateTo      = '';
  document.getElementById('searchInput').value    = '';
  document.getElementById('boolFilterInput').value = '';
  document.getElementById('dateFrom').value        = '';
  document.getElementById('dateTo').value          = '';
  updateFilterBar();
  loadDocuments();
  loadTagSummary();
}

function updateFilterBar() {
  const bar   = document.getElementById('filterBar');
  const label = document.getElementById('filterLabel');
  const parts = [];
  if (activeSearchQuery) parts.push(`Search: "${activeSearchQuery}"`);
  if (activeTagFilter)   parts.push(`Tag: #${activeTagFilter}`);
  if (activeBoolFilter)  parts.push(activeBoolFilter.map((t, i) =>
    (i === 0 ? '' : t.op + ' ') + '#' + t.tag).join(' '));
  if (activeDateFrom || activeDateTo) {
    parts.push(`Date: ${activeDateFrom || '…'}–${activeDateTo || '…'}`);
  }
  if (parts.length) {
    bar.style.display = '';
    label.textContent = parts.join(' · ');
  } else {
    bar.style.display = 'none';
    label.textContent = '';
  }
}

document.getElementById('sortSelect').addEventListener('change', e => {
  currentSort = e.target.value;
  loadDocuments();
});

document.getElementById('searchBtn').addEventListener('click', doSearch);
document.getElementById('searchInput').addEventListener('keydown', e => {
  if (e.key === 'Enter') doSearch();
  if (e.key === 'Escape') clearFilter();
});

function applyDateFilter() {
  activeDateFrom = document.getElementById('dateFrom').value.trim();
  activeDateTo   = document.getElementById('dateTo').value.trim();
  updateFilterBar();
  loadDocuments();
}
for (const id of ['dateFrom', 'dateTo']) {
  document.getElementById(id).addEventListener('keydown', e => {
    if (e.key === 'Enter') applyDateFilter();
  });
  document.getElementById(id).addEventListener('blur', applyDateFilter);
}

// ── Tag browser (sidebar) ─────────────────────────────────────────────────────

async function loadTagSummary() {
  const container = document.getElementById('tagList');
  try {
    const [tags, categories] = await Promise.all([
      fetch('/api/tags/summary').then(r => r.json()),
      fetch('/api/categories').then(r => r.json()),
    ]);
    window._lastTagSummary = tags;
    categoriesData = categories;
    renderTagBrowser(tags, categories);
    // If category editor is open, refresh its chip list
    if (activeCatEditorId) {
      const cat = categoriesData.find(c => c.id === activeCatEditorId);
      if (cat) renderCatEditorTags(cat);
      else closeCategoryEditor();
    }
  } catch {
    container.innerHTML = '<span class="error" style="font-size:0.82rem">Failed to load tags.</span>';
  }
}

function renderTagBrowser(tags, categories) {
  const container = document.getElementById('tagList');
  if (!tags.length) {
    container.innerHTML =
      '<span style="color:#ccc; font-size:0.83rem; line-height:1.6">' +
      'No tags yet. Add tags to your documents to see them here.</span>';
    return;
  }

  // Build a lookup: tag -> {doc_count, highlight_count}
  const tagInfo = {};
  for (const t of tags) tagInfo[t.tag] = t;

  // Collect all categorized tags (may appear in multiple categories)
  const allCategorizedTags = new Set(categories.flatMap(c => c.tags));

  let html = '';

  // Render each category section
  for (const cat of categories) {
    const cid = escapeHtml(cat.id);
    const cname = escapeHtml(JSON.stringify(cat.name));
    html += `<div class="cat-section">`;
    html += `<div class="cat-header" data-cat-id="${cid}">
      <span class="cat-header-label">${escapeHtml(cat.name)}</span>
      <div class="cat-header-actions">
        <button onclick="event.stopPropagation();confirmDeleteCat('${cid}',${cname})" title="Delete category">🗑</button>
      </div>
    </div>`;
    html += `<div class="cat-body">`;
    for (const tag of cat.tags) {
      const info = tagInfo[tag] || { doc_count: 0 };
      const isActive = activeTagFilter === tag;
      html += `<div class="tag-bar${isActive ? ' active' : ''}" data-browse-tag="${escapeHtml(tag)}">
        <span class="tag-bar-label">#${escapeHtml(tag)}</span>
        <div class="tag-bar-actions">
          <button class="tag-edit-btn" data-edit-tag="${escapeHtml(tag)}" title="Rename tag">✎</button>
          <button class="tag-delete-btn" data-delete-tag="${escapeHtml(tag)}" title="Delete tag corpus-wide">🗑</button>
        </div>
        <button class="cat-remove-tag" data-cat-id="${escapeHtml(cat.id)}" data-cat-tag="${escapeHtml(tag)}" title="Remove from this category">×</button>
        <span class="tag-bar-count">${info.doc_count || ''}</span>
      </div>`;
    }
    // Add-tag row for this category
    const dataListId = `cat-tags-list-${cat.id}`;
    const tagsNotInCat = tags.map(t => t.tag).filter(t => !cat.tags.includes(t));
    html += `<div class="cat-add-row">
      <button class="cat-add-btn" data-cat-add="${escapeHtml(cat.id)}" title="Add tag to category">+ Add tag…</button>
      <input class="cat-add-input" id="cat-add-input-${escapeHtml(cat.id)}" style="display:none"
             list="${dataListId}" placeholder="tag name…"
             data-cat-id="${escapeHtml(cat.id)}">
      <datalist id="${dataListId}">
        ${tagsNotInCat.map(t => `<option value="${escapeHtml(t)}">`).join('')}
      </datalist>
    </div>`;
    html += `</div>`; // cat-body
    html += `</div>`; // cat-section
  }

  // Uncategorized section
  const uncategorized = tags.filter(t => !allCategorizedTags.has(t.tag));
  if (uncategorized.length) {
    html += `<div class="cat-section">`;
    html += `<div class="cat-header" style="cursor:default">
      <span class="cat-header-label">Uncategorized</span>
    </div>`;
    html += `<div class="cat-body">`;
    for (const t of uncategorized) {
      const isActive = activeTagFilter === t.tag;
      html += `<div class="tag-bar${isActive ? ' active' : ''}" data-browse-tag="${escapeHtml(t.tag)}">
        <span class="tag-bar-label">#${escapeHtml(t.tag)}</span>
        <div class="tag-bar-actions">
          <button class="tag-edit-btn" data-edit-tag="${escapeHtml(t.tag)}" title="Rename tag">✎</button>
          <button class="tag-delete-btn" data-delete-tag="${escapeHtml(t.tag)}" title="Delete tag corpus-wide">🗑</button>
        </div>
        <span class="tag-bar-count">${t.doc_count || ''}</span>
      </div>`;
    }
    html += `</div></div>`;
  }

  container.innerHTML = html;

  // Wire add-tag inputs (keydown events)
  container.querySelectorAll('.cat-add-input').forEach(input => {
    input.addEventListener('keydown', async e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        const catId = input.dataset.catId;
        const tag   = input.value.trim().toLowerCase().replace(/\s+/g, '-');
        if (!tag) return;
        await addTagToCategory(catId, tag);
      } else if (e.key === 'Escape') {
        input.style.display = 'none';
        input.previousElementSibling?.style.removeProperty('display');
      }
    });
    input.addEventListener('blur', () => {
      // Hide input if user clicks away without submitting
      setTimeout(() => {
        if (document.activeElement !== input) {
          input.style.display = 'none';
          const addBtn = input.closest('.cat-add-row')?.querySelector('.cat-add-btn');
          if (addBtn) addBtn.style.removeProperty('display');
        }
      }, 150);
    });
  });
}

document.getElementById('tagList').addEventListener('click', async e => {
  // Open category editor (click on a category header; delete button uses stopPropagation)
  const catHeaderEl = e.target.closest('.cat-header[data-cat-id]');
  if (catHeaderEl) { openCategoryEditor(catHeaderEl.dataset.catId); return; }

  // Remove tag from category (× button)
  const removeTagBtn = e.target.closest('.cat-remove-tag');
  if (removeTagBtn) {
    e.stopPropagation();
    await removeTagFromCategory(removeTagBtn.dataset.catId, removeTagBtn.dataset.catTag);
    return;
  }

  // Show add-tag input
  const addBtn = e.target.closest('.cat-add-btn');
  if (addBtn) {
    e.stopPropagation();
    const catId = addBtn.dataset.catAdd;
    const input = document.getElementById(`cat-add-input-${catId}`);
    if (input) {
      addBtn.style.display = 'none';
      input.style.display = 'block';
      input.focus();
    }
    return;
  }

  // Edit button — replace tag bar with inline input form
  const editBtn = e.target.closest('.tag-edit-btn');
  if (editBtn) { e.stopPropagation(); startTagEdit(editBtn.dataset.editTag); return; }

  // Delete button — remove tag corpus-wide after confirm
  const delBtn = e.target.closest('.tag-delete-btn');
  if (delBtn) {
    e.stopPropagation();
    const tag = delBtn.dataset.deleteTag;
    if (!confirm(`Delete tag #${tag} from all documents and annotations?\nThis cannot be undone.`)) return;
    await deleteTagCorpusWide(tag);
    return;
  }

  // Save rename
  const saveBtn = e.target.closest('.tag-editor-save');
  if (saveBtn) {
    e.stopPropagation();
    const oldTag  = saveBtn.dataset.oldTag;
    const input   = document.getElementById('tag-editor-input-' + oldTag);
    const newTag  = input?.value.trim().toLowerCase().replace(/\s+/g, '-') ?? '';
    if (!newTag) { if (input) { input.style.borderColor = '#e53935'; input.focus(); } return; }
    await saveTagRename(oldTag, newTag);
    return;
  }

  // Cancel edit — restore original tag bar
  const cancelBtn = e.target.closest('.tag-editor-cancel');
  if (cancelBtn) { e.stopPropagation(); loadTagSummary(); return; }

  // Browse by tag (click on bar, not action buttons or cat-remove-tag)
  const bar = e.target.closest('[data-browse-tag]');
  if (bar && !e.target.closest('.tag-bar-actions') && !e.target.closest('.cat-remove-tag')) {
    browseTag(bar.dataset.browseTag);
  }
});

function startTagEdit(tag) {
  const bar = document.querySelector(`.tag-bar[data-browse-tag="${CSS.escape(tag)}"]`);
  if (!bar) return;
  bar.outerHTML = `
    <div class="tag-editor-row" data-editing-tag="${escapeHtml(tag)}">
      <input id="tag-editor-input-${escapeHtml(tag)}" class="tag-editor-input"
             type="text" value="${escapeHtml(tag)}" placeholder="new tag name"
             onkeydown="if(event.key==='Enter'){event.preventDefault();
               document.querySelector('.tag-editor-save[data-old-tag=\\'${escapeHtml(tag)}\\']')?.click();}
               else if(event.key==='Escape'){document.querySelector('.tag-editor-cancel[data-old-tag=\\'${escapeHtml(tag)}\\']')?.click();}">
      <button class="tag-editor-btn save tag-editor-save" data-old-tag="${escapeHtml(tag)}">✓</button>
      <button class="tag-editor-btn cancel tag-editor-cancel" data-old-tag="${escapeHtml(tag)}">✕</button>
    </div>`;
  document.getElementById('tag-editor-input-' + tag)?.focus();
  const input = document.getElementById('tag-editor-input-' + tag);
  if (input) input.select();
}

async function saveTagRename(oldTag, newTag) {
  try {
    const r = await fetch('/api/tags/' + encodeURIComponent(oldTag), {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ newTag }),
    });
    if (!r.ok) throw new Error((await r.json()).error || 'Rename failed');
    if (activeTagFilter === oldTag) activeTagFilter = newTag;
    await refreshCorpus();
  } catch (err) {
    alert('Could not rename tag: ' + err.message);
    loadTagSummary();
  }
}

async function deleteTagCorpusWide(tag) {
  try {
    const r = await fetch('/api/tags/' + encodeURIComponent(tag), { method: 'DELETE' });
    if (!r.ok) throw new Error((await r.json()).error || 'Delete failed');
    if (activeTagFilter === tag) { activeTagFilter = null; updateFilterBar(); }
    await refreshCorpus();
    if (currentDocId) viewDocument(currentDocId);
  } catch (err) {
    alert('Could not delete tag: ' + err.message);
  }
}

// ── Category actions ──────────────────────────────────────────────────────────

function toggleNewCatForm() {
  const form = document.getElementById('newCatForm');
  const input = document.getElementById('newCatInput');
  if (form.style.display === 'none') {
    form.style.display = '';
    input.value = '';
    input.focus();
  } else {
    form.style.display = 'none';
  }
}

async function createCategory() {
  const input = document.getElementById('newCatInput');
  const name = input.value.trim();
  if (!name) { input.style.borderColor = '#e53935'; input.focus(); return; }
  try {
    const r = await fetch('/api/categories', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name }),
    });
    if (!r.ok) throw new Error((await r.json()).error || 'Create failed');
    document.getElementById('newCatForm').style.display = 'none';
    await loadTagSummary();
  } catch (err) { alert('Could not create category: ' + err.message); }
}


async function deleteCategory(catId) {
  try {
    const r = await fetch('/api/categories/' + encodeURIComponent(catId), { method: 'DELETE' });
    if (!r.ok) throw new Error((await r.json()).error || 'Delete failed');
    await loadTagSummary();
  } catch (err) { alert('Could not delete category: ' + err.message); }
}

async function addTagToCategory(catId, tag) {
  try {
    const r = await fetch(`/api/categories/${encodeURIComponent(catId)}/tags/${encodeURIComponent(tag)}`, { method: 'POST' });
    if (!r.ok) throw new Error((await r.json()).error || 'Add failed');
    await loadTagSummary();
  } catch (err) { alert('Could not add tag: ' + err.message); }
}

async function removeTagFromCategory(catId, tag) {
  try {
    const r = await fetch(`/api/categories/${encodeURIComponent(catId)}/tags/${encodeURIComponent(tag)}`, { method: 'DELETE' });
    if (!r.ok) throw new Error((await r.json()).error || 'Remove failed');
    await loadTagSummary();
  } catch (err) { alert('Could not remove tag from category: ' + err.message); }
}


async function confirmDeleteCat(catId, name) {
  if (!confirm(`Delete category "${name}"?\nTags will not be deleted — they'll become uncategorized.`)) return;
  await deleteCategory(catId);
}

// ── Category editor (center column) ──────────────────────────────────────────

let activeCatEditorId = null;

function openCategoryEditor(catId) {
  const cat = categoriesData.find(c => c.id === catId);
  if (!cat) return;
  activeCatEditorId = catId;

  // Switch panels
  document.getElementById('libraryPanel').style.display = 'none';
  const panel = document.getElementById('catEditorPanel');
  panel.style.display = 'flex';

  // Populate header fields
  const nameInput = document.getElementById('catEditorName');
  const colorInput = document.getElementById('catEditorColor');
  const dot = document.getElementById('catEditorDot');
  nameInput.value = cat.name;
  colorInput.value = cat.color;
  dot.style.background = cat.color;

  renderCatEditorTags(cat);
}

function renderCatEditorTags(cat) {
  const list = document.getElementById('catEditorTagList');
  const allTags = window._lastTagSummary || [];
  list.innerHTML = allTags.map(t => {
    const inCat = cat.tags.includes(t.tag);
    return `<span class="cat-tag-chip${inCat ? ' in-cat' : ''}"
      onclick="toggleTagInCategory('${escapeHtml(cat.id)}','${escapeHtml(t.tag)}')"
      title="${inCat ? 'Remove from category' : 'Add to category'}">${escapeHtml(t.tag)}</span>`;
  }).join('');
}

async function toggleTagInCategory(catId, tag) {
  const cat = categoriesData.find(c => c.id === catId);
  if (!cat) return;
  const inCat = cat.tags.includes(tag);
  const url = `/api/categories/${encodeURIComponent(catId)}/tags/${encodeURIComponent(tag)}`;
  try {
    const r = await fetch(url, { method: inCat ? 'DELETE' : 'POST' });
    if (!r.ok) throw new Error((await r.json()).error);
    // Update local state immediately for responsive feel
    if (inCat) cat.tags = cat.tags.filter(t => t !== tag);
    else cat.tags = [...cat.tags, tag];
    renderCatEditorTags(cat);
    loadTagSummary();
  } catch (err) { alert('Error: ' + err.message); }
}

async function saveCategoryName() {
  if (!activeCatEditorId) return;
  const name = document.getElementById('catEditorName').value.trim();
  if (!name) return;
  try {
    const r = await fetch('/api/categories/' + encodeURIComponent(activeCatEditorId), {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name }),
    });
    if (!r.ok) throw new Error((await r.json()).error);
    const cat = categoriesData.find(c => c.id === activeCatEditorId);
    if (cat) cat.name = name;
    loadTagSummary();
  } catch (err) { alert('Could not rename: ' + err.message); }
}

async function saveCategoryColor() {
  if (!activeCatEditorId) return;
  const color = document.getElementById('catEditorColor').value;
  try {
    const r = await fetch('/api/categories/' + encodeURIComponent(activeCatEditorId), {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ color }),
    });
    if (!r.ok) throw new Error((await r.json()).error);
    const cat = categoriesData.find(c => c.id === activeCatEditorId);
    if (cat) cat.color = color;
    loadTagSummary();
  } catch (err) { alert('Could not update colour: ' + err.message); }
}

async function deleteCategoryFromEditor() {
  const cat = categoriesData.find(c => c.id === activeCatEditorId);
  if (!cat) return;
  if (!confirm(`Delete category "${cat.name}"?\nTags will not be deleted.`)) return;
  try {
    const r = await fetch('/api/categories/' + encodeURIComponent(activeCatEditorId), { method: 'DELETE' });
    if (!r.ok) throw new Error((await r.json()).error);
    closeCategoryEditor();
    await loadTagSummary();
  } catch (err) { alert('Could not delete category: ' + err.message); }
}

function closeCategoryEditor() {
  activeCatEditorId = null;
  document.getElementById('catEditorPanel').style.display = 'none';
  document.getElementById('libraryPanel').style.removeProperty('display');
}

function browseTag(tag) {
  activeTagFilter   = tag;
  activeSearchQuery = null;
  activeBoolFilter  = null;
  document.getElementById('searchInput').value     = '';
  document.getElementById('boolFilterInput').value = '';
  updateFilterBar();
  loadDocuments();
  loadTagSummary();
}

// ── Document viewer ───────────────────────────────────────────────────────────

function renderInlineMarkup(rawContent) {
  let html = escapeHtml(rawContent);
  html = html.replace(/==([^=\n]+?)==/g, (_, text) =>
    `<mark class="inline-hl">${text}</mark>`);
  html = html.replace(/#([a-zA-Z][\w-]*)/g, (_, tag) =>
    `<span style="color:#5c6bc0; cursor:pointer; font-weight:500"
           onclick="browseTag('${escapeHtml(tag)}')">#${tag}</span>`);
  return html;
}

// Deterministic pastel colour per tag name
function tagColor(tag) {
  if (!tag) return 'hsla(48,100%,72%,0.55)';
  let h = 0;
  for (let i = 0; i < tag.length; i++) { h = ((h << 5) - h) + tag.charCodeAt(i); h |= 0; }
  return `hsla(${Math.abs(h) % 360},68%,72%,0.55)`;
}

// Render document content overlaying DB annotation highlights
function renderWithAnnotations(rawContent, annotations) {
  if (!annotations || !annotations.length) return renderInlineMarkup(rawContent);

  // Find all occurrences of each source_passage in the raw text
  const ranges = [];
  for (const ann of annotations) {
    if (!ann.source_passage) continue;
    let idx = rawContent.indexOf(ann.source_passage);
    while (idx !== -1) {
      ranges.push({ start: idx, end: idx + ann.source_passage.length, ann });
      idx = rawContent.indexOf(ann.source_passage, idx + 1);
    }
  }
  if (!ranges.length) return renderInlineMarkup(rawContent);

  ranges.sort((a, b) => a.start - b.start);

  let html = '', cursor = 0;
  for (const r of ranges) {
    if (r.start < cursor) continue;                     // skip overlapping ranges
    if (r.start > cursor)
      html += renderInlineMarkup(rawContent.slice(cursor, r.start));
    const bg  = tagColor(r.ann.tag);
    const tip = escapeHtml('#' + (r.ann.tag || 'note') +
      (r.ann.text && r.ann.text !== r.ann.source_passage ? ' · ' + r.ann.text : ''));
    html += `<mark class="ann-hl" style="background:${bg}" title="${tip}">`
          + renderInlineMarkup(rawContent.slice(r.start, r.end))
          + '</mark>';
    cursor = r.end;
  }
  if (cursor < rawContent.length) html += renderInlineMarkup(rawContent.slice(cursor));
  return html;
}

// Returns surrounding text from currentDocContent for context preview (Option A)
function getPassageContext(passage, contextLen = 130) {
  if (!currentDocContent || !passage) return null;
  const idx = currentDocContent.indexOf(passage);
  if (idx === -1) return null;
  const before = currentDocContent.slice(Math.max(0, idx - contextLen), idx);
  const after  = currentDocContent.slice(idx + passage.length,
                   Math.min(currentDocContent.length, idx + passage.length + contextLen));
  return { before, after };
}

// Annotation list rendered below the document body
function renderAnnotationList(anns) {
  if (!anns.length) return '';
  // Sort by position of the passage in the document so list order matches reading order
  anns = [...anns].sort((a, b) => {
    const ai = a.source_passage ? currentDocContent.indexOf(a.source_passage) : -1;
    const bi = b.source_passage ? currentDocContent.indexOf(b.source_passage) : -1;
    return ai - bi;
  });
  return `
    <div class="ann-list">
      <div class="ann-list-title">${anns.length} annotation${anns.length !== 1 ? 's' : ''}</div>
      ${anns.map(a => {
        const bg      = tagColor(a.tag);
        const solid   = bg.replace('0.55)', '1)');
        const passage = a.source_passage || '';
        const note    = (a.text && a.text !== a.source_passage) ? a.text : '';
        return `
          <div class="ann-item" style="border-left:3px solid ${solid}">
            <button class="btn-edit-ann" data-edit-ann="${escapeHtml(a.id)}"
                    data-tag="${escapeHtml(a.tag || '')}"
                    data-text="${escapeHtml(note)}"
                    data-passage="${escapeHtml(passage)}"
                    title="Edit annotation">✎</button>
            ${a.tag ? `<span class="ann-item-tag" style="background:${bg}">#${escapeHtml(a.tag)}</span>` : ''}
            ${passage ? `<div class="ann-item-passage">&ldquo;${escapeHtml(passage)}&rdquo;</div>` : ''}
            ${note    ? `<div class="ann-item-note">${escapeHtml(note)}</div>` : ''}
          </div>`;
      }).join('')}
    </div>`;
}

async function viewDocument(docId) {
  currentDocId = docId;
  hidePendingAnnotation();
  document.querySelectorAll('.doc-card').forEach(el =>
    el.classList.toggle('doc-active', el.dataset.docId === docId)
  );
  const panel  = document.getElementById('viewerContent');
  panel.innerHTML = '<span style="color:#ccc; font-size:0.88rem">Loading…</span>';
  try {
    const [doc, anns] = await Promise.all([
      fetch('/api/documents/' + docId).then(r => r.json()),
      fetch('/api/documents/' + docId + '/annotations').then(r => r.json()).catch(() => []),
    ]);
    currentDocContent = doc.content || '';

    const meta    = [doc.author, doc.publication_date].filter(Boolean).join(' · ');
    // Only use annotations with a source_passage (created by selection tool)
    const selAnns = anns.filter(a => a.source_passage && a.author_type === 'human');
    const count   = selAnns.length;

    const header = `
      <div class="viewer-doc-header">
        <strong style="font-size:0.95rem">${escapeHtml(doc.title || 'Untitled')}</strong>
        ${meta ? `<div style="font-size:0.8rem; color:#aaa; margin-top:0.2rem">${escapeHtml(meta)}</div>` : ''}
        ${count ? `<div style="font-size:0.75rem; color:#7986cb; margin-top:0.2rem">${count} annotation${count !== 1 ? 's' : ''}</div>` : ''}
      </div>`;
    const body    = renderWithAnnotations(currentDocContent, selAnns);
    const bodyHtml = showAnnotationsOnly ? '' : `<div class="viewer-body">${body}</div>`;
    const reselectBanner = reselectAnnId ? `
      <div style="background:#fff3e0; border:1px solid #ffb74d; border-radius:6px;
                  padding:0.45rem 0.8rem; margin-bottom:0.75rem; font-size:0.8rem;
                  color:#e65100; display:flex; align-items:center; gap:0.5rem">
        <span>Select a new passage in the text below, then tag and save</span>
        <button onclick="cancelReselect()"
                style="margin-left:auto; background:none; border:none; color:#bbb;
                       cursor:pointer; font-size:0.9rem; line-height:1; padding:0">✕ cancel</button>
      </div>` : '';
    panel.innerHTML = header + reselectBanner + bodyHtml + renderAnnotationList(selAnns);
  } catch {
    panel.innerHTML = '<span class="error">Failed to load document.</span>';
  }
}

// ── Annotation create panel (inline, always in viewer column) ─────────────────

let pendingText = null;

document.getElementById('pending-save').addEventListener('click', async () => {
  const tag  = document.getElementById('pending-tag').value.trim();
  const note = document.getElementById('pending-note').value.trim();
  if (!tag) {
    document.getElementById('pending-tag').style.borderColor = '#e53935';
    document.getElementById('pending-tag').focus();
    return;
  }
  const text = pendingText;
  hidePendingAnnotation();
  window.getSelection()?.removeAllRanges();
  await saveAnnotation(text, tag.toLowerCase().replace(/\s+/g, '-'), note);
});

document.getElementById('pending-cancel').addEventListener('click', () => {
  hidePendingAnnotation();
  window.getSelection()?.removeAllRanges();
  if (reselectAnnId) cancelReselect();
});

for (const inputId of ['pending-tag', 'pending-note']) {
  document.getElementById(inputId).addEventListener('keydown', e => {
    if (e.key === 'Enter')  { e.preventDefault(); document.getElementById('pending-save').click(); }
    if (e.key === 'Tab' && inputId === 'pending-tag')
      { e.preventDefault(); document.getElementById('pending-note').focus(); }
    if (e.key === 'Escape') { document.getElementById('pending-cancel').click(); }
  });
}

document.getElementById('viewerContent').addEventListener('mouseup', () => {
  setTimeout(() => {
    const sel = window.getSelection();
    if (!sel || sel.isCollapsed || !currentDocId) return;
    const text = sel.toString().trim();
    if (text.length < 2) return;
    const range = sel.getRangeAt(0);
    if (!document.getElementById('viewerContent').contains(range.commonAncestorContainer)) return;
    showPendingAnnotation(text);
  }, 10);
});

function showPendingAnnotation(selectedText) {
  pendingText = selectedText;
  document.getElementById('pending-ann-title').textContent =
    reselectAnnId ? 'Update passage' : 'New annotation';
  document.getElementById('pending-passage-preview').textContent =
    '\u201c' + selectedText + '\u201d';
  document.getElementById('pending-tag').value  = reselectAnnId ? reselectTag  : '';
  document.getElementById('pending-note').value = reselectAnnId ? reselectNote : '';
  document.getElementById('pending-save').textContent = reselectAnnId ? 'Update' : 'Annotate';
  document.getElementById('pending-tag').style.borderColor = '';
  document.getElementById('pending-annotation').hidden = false;
  document.getElementById('pending-tag').focus();
}

function hidePendingAnnotation() {
  document.getElementById('pending-annotation').hidden = true;
  document.getElementById('pending-tag').value  = '';
  document.getElementById('pending-note').value = '';
  pendingText = null;
}

async function saveAnnotation(sourcePassage, tag, note) {
  if (!currentDocId) return;
  const startOffset = currentDocContent ? currentDocContent.indexOf(sourcePassage) : -1;
  const endOffset   = startOffset >= 0 ? startOffset + sourcePassage.length : -1;

  // Option C: re-select mode — PATCH the existing annotation instead of creating a new one
  if (reselectAnnId) {
    const annId = reselectAnnId;
    reselectAnnId = null; reselectTag = ''; reselectNote = '';
    try {
      const r = await fetch('/api/annotations/' + annId, {
        method:  'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          source_passage: sourcePassage,
          tag,
          ...(note ? { text: note } : {}),
        }),
      });
      if (!r.ok) throw new Error((await r.json()).error || 'Update failed');
      await viewDocument(currentDocId);
      loadTagSummary();
      refreshCorpus();
    } catch (err) {
      alert('Could not update annotation: ' + err.message);
    }
    return;
  }

  try {
    const r = await fetch('/api/documents/' + currentDocId + '/annotations', {
      method:  'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        source_passage: sourcePassage,
        text:           note || null,
        tag,
        author_id:      'researcher',
        start_offset:   startOffset >= 0 ? startOffset : null,
        end_offset:     endOffset   >= 0 ? endOffset   : null,
      }),
    });
    if (!r.ok) throw new Error((await r.json()).error || 'Save failed');
    await viewDocument(currentDocId);   // refresh viewer with new highlight
    loadTagSummary();                   // new tag may have appeared in sidebar
    refreshCorpus();                    // update doc card in centre column
  } catch (err) {
    alert('Could not save annotation: ' + err.message);
  }
}

// ── Edit annotation (inline form) ─────────────────────────────────────────────

document.getElementById('viewerContent').addEventListener('click', async e => {
  // Pencil button — show inline edit form
  const editBtn = e.target.closest('[data-edit-ann]');
  if (editBtn) {
    const { editAnn, tag, text, passage } = editBtn.dataset;
    showAnnotationEditForm(editAnn, tag, text, passage);
    return;
  }
  // Save edit
  const saveBtn = e.target.closest('[data-save-ann-edit]');
  if (saveBtn) { await saveAnnotationEdit(saveBtn.dataset.saveAnnEdit); return; }
  // Cancel edit
  const cancelBtn = e.target.closest('[data-cancel-ann-edit]');
  if (cancelBtn) {
    const panel = document.getElementById('viewerContent');
    const savedScroll = panel.scrollTop;
    await viewDocument(currentDocId);
    panel.scrollTop = savedScroll;
    return;
  }
  // Re-select passage (Option C)
  const reselectBtn = e.target.closest('[data-reselect-ann]');
  if (reselectBtn) {
    startReselect(reselectBtn.dataset.reselectAnn, reselectBtn.dataset.tag, reselectBtn.dataset.text);
    return;
  }
  // Delete annotation
  const deleteBtn = e.target.closest('[data-delete-ann]');
  if (deleteBtn) { await deleteAnnotation(deleteBtn.dataset.deleteAnn); return; }
});

function showAnnotationEditForm(annId, tag, note, passage) {
  const btn  = document.querySelector(`[data-edit-ann="${CSS.escape(annId)}"]`);
  if (!btn) return;
  const item = btn.closest('.ann-item');
  if (!item) return;

  // Option A: context preview — surrounding text with passage highlighted
  const ctx = getPassageContext(passage);
  const contextHtml = ctx ? `
    <div>
      <label style="font-size:0.74rem; color:#888">Context</label>
      <div style="font-size:0.78rem; color:#555; background:#f5f6fa; border-radius:5px;
                  padding:0.4rem 0.65rem; line-height:1.65; white-space:pre-wrap;
                  word-break:break-word; max-height:5.5rem; overflow-y:auto"><!--
     -->${ctx.before ? `<span style="color:#bbb">${escapeHtml(ctx.before)}</span>` : ''}<!--
     --><strong style="background:#fff9c4; border-radius:2px; padding:0 1px">${escapeHtml(passage)}</strong><!--
     -->${ctx.after  ? `<span style="color:#bbb">${escapeHtml(ctx.after)}</span>`  : ''}
      </div>
    </div>` : '';

  item.innerHTML = `
    <div style="display:flex; flex-direction:column; gap:0.4rem">
      <div style="display:flex; gap:0.4rem; align-items:center">
        <label style="font-size:0.74rem; color:#888; white-space:nowrap">Tag</label>
        <input id="edit-ann-tag-${escapeHtml(annId)}" type="text" value="${escapeHtml(tag)}"
               style="flex:1; padding:0.22rem 0.45rem; border:1px solid #c5cae9;
                      border-radius:5px; font-size:0.8rem; font-family:inherit">
      </div>
      ${contextHtml}
      <div>
        <label style="font-size:0.74rem; color:#888">Passage</label>
        <textarea id="edit-ann-passage-${escapeHtml(annId)}" rows="5"
                  style="width:100%; padding:0.22rem 0.45rem; border:1px solid #dde1ea;
                         border-radius:5px; font-size:0.8rem; font-family:inherit;
                         resize:vertical">${escapeHtml(passage)}</textarea>
      </div>
      <div>
        <label style="font-size:0.74rem; color:#888">Note</label>
        <textarea id="edit-ann-note-${escapeHtml(annId)}" rows="3"
                  style="width:100%; padding:0.22rem 0.45rem; border:1px solid #dde1ea;
                         border-radius:5px; font-size:0.8rem; font-family:inherit;
                         resize:vertical">${escapeHtml(note)}</textarea>
      </div>
      <div style="display:flex; gap:0.4rem; align-items:center; flex-wrap:wrap">
        <button data-save-ann-edit="${escapeHtml(annId)}"
                style="background:#5c6bc0; color:white; border:none; border-radius:5px;
                       padding:0.25rem 0.75rem; font-size:0.8rem; cursor:pointer; font-family:inherit">
          Save
        </button>
        <button data-cancel-ann-edit="${escapeHtml(annId)}"
                style="background:none; border:none; color:#bbb; cursor:pointer;
                       font-size:0.8rem; font-family:inherit">
          Cancel
        </button>
        <button data-reselect-ann="${escapeHtml(annId)}"
                data-tag="${escapeHtml(tag)}" data-text="${escapeHtml(note)}"
                style="background:none; border:none; color:#5c6bc0; cursor:pointer;
                       font-size:0.79rem; font-family:inherit; padding:0; margin-left:auto">
          ↩ Re-select passage
        </button>
        <button data-delete-ann="${escapeHtml(annId)}"
                style="background:none; border:none; color:#e57373; cursor:pointer;
                       font-size:0.79rem; font-family:inherit; padding:0">
          🗑 Delete
        </button>
      </div>
    </div>`;
  document.getElementById('edit-ann-tag-' + annId)?.focus();
}

async function saveAnnotationEdit(annId) {
  const tagEl     = document.getElementById('edit-ann-tag-'     + annId);
  const passageEl = document.getElementById('edit-ann-passage-' + annId);
  const noteEl    = document.getElementById('edit-ann-note-'    + annId);

  const tag     = tagEl?.value.trim()     ?? '';
  const passage = passageEl?.value.trim() ?? '';
  const note    = noteEl?.value.trim()    ?? '';

  if (!tag) {
    if (tagEl) { tagEl.style.borderColor = '#e53935'; tagEl.focus(); }
    return;
  }

  const body = {
    tag:  tag.toLowerCase().replace(/\s+/g, '-'),
    text: note,
    ...(passage && { source_passage: passage }),
  };

  const panel = document.getElementById('viewerContent');
  const savedScroll = panel.scrollTop;
  try {
    const r = await fetch('/api/annotations/' + annId, {
      method:  'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body:    JSON.stringify(body),
    });
    if (!r.ok) throw new Error((await r.json()).error || 'Update failed');
    await viewDocument(currentDocId);
    panel.scrollTop = savedScroll;
    await refreshCorpus();
  } catch (err) {
    alert('Could not update annotation: ' + err.message);
  }
}

async function deleteAnnotation(annId) {
  const panel = document.getElementById('viewerContent');
  const savedScroll = panel.scrollTop;
  try {
    const r = await fetch('/api/annotations/' + annId, { method: 'DELETE' });
    if (!r.ok) throw new Error((await r.json()).error || 'Delete failed');
    await viewDocument(currentDocId);
    panel.scrollTop = savedScroll;
    loadTagSummary();
    refreshCorpus();
  } catch (err) {
    alert('Could not delete annotation: ' + err.message);
  }
}

function startReselect(annId, tag, note) {
  reselectAnnId  = annId;
  reselectTag    = tag  || '';
  reselectNote   = note || '';
  viewDocument(currentDocId);   // re-render: closes edit form, shows banner
}

function cancelReselect() {
  reselectAnnId = null;
  reselectTag   = '';
  reselectNote  = '';
  viewDocument(currentDocId);   // re-render: removes banner
}

// ── Delete ────────────────────────────────────────────────────────────────────

async function deleteDoc(id) {
  if (!confirm('Delete this document from the corpus? This cannot be undone.')) return;
  await fetch(`/api/documents/${id}`, { method: 'DELETE' });
  refreshCorpus();
}


document.getElementById('exportBtn').addEventListener('click', async () => {
  const r = await fetch('/api/documents');
  const docs = await r.json();
  if (!docs.length) { alert('Nothing to export — corpus is empty.'); return; }
  window.location.href = '/api/export';
});

document.getElementById('deleteAllBtn').addEventListener('click', async () => {
  const res   = await fetch('/api/documents');
  const docs  = await res.json();
  const count = docs.length;
  if (!count) { alert('The corpus is already empty.'); return; }
  if (!confirm(
    `Delete all ${count} document${count > 1 ? 's' : ''} and their notes?\nThis cannot be undone.`
  )) return;
  const typed = prompt('Type DELETE to confirm:');
  if ((typed ?? '').toUpperCase() !== 'DELETE') return;
  try {
    const r = await fetch('/api/corpus', { method: 'DELETE' });
    if (!r.ok) {
      const body = await r.text();
      let msg = `HTTP ${r.status}`;
      try { msg = JSON.parse(body).error || msg; } catch { msg = body || msg; }
      throw new Error(msg);
    }
    refreshCorpus();
  } catch (err) { alert('Delete failed: ' + err.message); }
});

// ── Supabase sync ─────────────────────────────────────────────────────────────

async function pollSyncStatus() {
  try {
    const s   = await fetch('/api/sync/status').then(r => r.json());
    const el  = document.getElementById('syncStatusBadge');
    const btn = document.getElementById('syncBtn');
    if (!s.configured) { el.textContent = ''; btn.style.display = 'none'; return; }
    btn.style.display = '';
    const dirty = (s.dirty_documents || 0) + (s.dirty_annotations || 0);
    if (dirty > 0) { el.textContent = `${dirty} unsynced`; el.style.color = '#e65100'; }
    else {
      el.textContent = s.last_sync_at ? `Synced ${new Date(s.last_sync_at).toLocaleTimeString()}` : 'Not synced';
      el.style.color = '#2e7d32';
    }
  } catch { /* ignore */ }
}

async function triggerSync() {
  const btn = document.getElementById('syncBtn');
  const el  = document.getElementById('syncStatusBadge');
  btn.disabled = true; btn.textContent = 'Syncing…';
  el.textContent = 'Syncing…'; el.style.color = '#5c6bc0';
  try {
    const r    = await fetch('/api/sync', { method: 'POST' });
    const data = await r.json();
    if (!r.ok) throw new Error(data.error);
    await pollSyncStatus();
    loadDocuments();
  } catch (err) {
    el.textContent = '✗ Sync failed'; el.style.color = '#c62828';
    alert('Sync failed: ' + err.message);
  } finally { btn.disabled = false; btn.textContent = '↑↓ Sync'; }
}

setInterval(pollSyncStatus, 10000);

// ── Collapsible card arrows ───────────────────────────────────────────────────

document.querySelectorAll('details.card').forEach(d => {
  d.addEventListener('toggle', function () {
    const arrow = this.querySelector('.arrow');
    if (arrow) arrow.textContent = this.open ? '▾' : '▸';
  });
});

// ── Annotations-only toggle ───────────────────────────────────────────────────

document.getElementById('annotationsOnlyToggle').addEventListener('change', e => {
  showAnnotationsOnly = e.target.checked;
  if (currentDocId) viewDocument(currentDocId);
});

// ── Viewer / Analysis tab switching ───────────────────────────────────────────

function switchTab(tab) {
  activeViewerTab = tab;
  const isDoc = tab === 'document';
  document.getElementById('viewerContent').style.display            = isDoc ? '' : 'none';
  document.getElementById('analysisPanel').style.display            = isDoc ? 'none' : 'flex';
  document.getElementById('annotationsOnlyWrap').style.display      = isDoc ? '' : 'none';
  if (!isDoc) document.getElementById('pending-annotation').hidden  = true;
  document.getElementById('tabDocument').classList.toggle('tab-active', isDoc);
  document.getElementById('tabAnalysis').classList.toggle('tab-active', !isDoc);
  if (!isDoc) showAnalysis(activeAnalysisTab);
}

function showAnalysis(tab) {
  activeAnalysisTab = tab;
  const panels = {
    kwic:     ['anaPanelKwic',     'flex'],
    collo:    ['anaPanelCollo',    'flex'],
    freq:     ['anaPanelFreq',     'flex'],
    cooc:     ['anaPanelCooc',     'block'],
    timeline: ['anaPanelTimeline', 'block'],
  };
  const tabIds = {
    kwic: 'anaTabKwic', collo: 'anaTabCollo', freq: 'anaTabFreq',
    cooc: 'anaTabCooc', timeline: 'anaTabTimeline',
  };
  for (const [t, [panelId, display]] of Object.entries(panels)) {
    const el = document.getElementById(panelId);
    if (el) el.style.display = t === tab ? display : 'none';
    document.getElementById(tabIds[t])?.classList.toggle('ana-active', t === tab);
  }
  if (tab === 'cooc'     && !coocLoaded)     { loadCooccurrence(); coocLoaded = true; }
  if (tab === 'timeline' && !timelineLoaded) { loadTimeline();     timelineLoaded = true; }
}

// ── KWIC concordance ──────────────────────────────────────────────────────────

document.getElementById('kwicBtn').addEventListener('click', runKwic);
document.getElementById('kwicInput').addEventListener('keydown', e => {
  if (e.key === 'Enter') runKwic();
});
document.getElementById('kwicResults').addEventListener('click', e => {
  const row = e.target.closest('[data-view-doc]');
  if (row) { switchTab('document'); viewDocument(row.dataset.viewDoc); }
});

async function runKwic() {
  const term    = document.getElementById('kwicInput').value.trim();
  const results = document.getElementById('kwicResults');
  if (!term) return;
  results.innerHTML = '<span style="color:#ccc; font-size:0.83rem">Searching…</span>';
  try {
    const data = await fetch('/api/analysis/kwic?q=' + encodeURIComponent(term)).then(r => r.json());
    if (!data.length) {
      results.innerHTML = '<span style="color:#ccc; font-size:0.83rem">No occurrences found.</span>';
      return;
    }
    const header = `<div style="font-size:0.72rem; color:#bbb; margin-bottom:0.4rem; flex-shrink:0">${data.length}${data.length >= 200 ? '+' : ''} occurrence${data.length !== 1 ? 's' : ''}</div>`;
    const rows = data.map(r =>
      `<div class="kwic-row" data-view-doc="${escapeHtml(r.doc_id)}">
        <div class="kwic-left">${escapeHtml(r.left)}</div>
        <div class="kwic-match">${escapeHtml(r.match)}</div>
        <div class="kwic-right">${escapeHtml(r.right)}</div>
        <div class="kwic-meta">${escapeHtml(r.doc_date || '')}</div>
      </div>`
    ).join('');
    results.innerHTML = header + rows;
  } catch (err) {
    results.innerHTML = `<span class="error" style="font-size:0.82rem">Error: ${escapeHtml(err.message)}</span>`;
  }
}

// ── Collocates ────────────────────────────────────────────────────────────────

document.getElementById('colloBtn').addEventListener('click', runCollocates);
document.getElementById('colloInput').addEventListener('keydown', e => {
  if (e.key === 'Enter') runCollocates();
});

async function runCollocates() {
  const term    = document.getElementById('colloInput').value.trim();
  const results = document.getElementById('colloResults');
  if (!term) return;
  results.innerHTML = '<span style="color:#ccc; font-size:0.83rem">Searching…</span>';
  try {
    const data = await fetch('/api/analysis/collocates?q=' + encodeURIComponent(term)).then(r => r.json());
    if (!data.length) {
      results.innerHTML = '<span style="color:#ccc; font-size:0.83rem">No collocates found — term may not appear in corpus.</span>';
      return;
    }
    const maxCount = data[0].count;
    // Font size range: 0.78rem – 1.5rem; colour darkens with frequency
    const items = data.map(({ word, count }) => {
      const t   = count / maxCount;                         // 0–1
      const rem = (0.78 + t * 0.72).toFixed(2);
      const lum = Math.round(72 - t * 38);                 // 72% → 34%
      const col = `hsl(230,45%,${lum}%)`;
      return `<span style="font-size:${rem}rem; color:${col}; cursor:pointer; line-height:1.75;
                           display:inline-block; margin:0.1rem 0.25rem"
                    title="${count} occurrence${count !== 1 ? 's' : ''}"
                    onclick="document.getElementById('kwicInput').value='${escapeHtml(word)}';
                             showAnalysis('kwic'); runKwic()">${escapeHtml(word)}</span>`;
    }).join('');
    results.innerHTML = `
      <div style="font-size:0.72rem; color:#bbb; margin-bottom:0.55rem">
        ${data.length} collocates of <em>${escapeHtml(term)}</em> · click a word to view in KWIC
      </div>
      <div style="line-height:1.9">${items}</div>`;
  } catch (err) {
    results.innerHTML = `<span class="error" style="font-size:0.82rem">Error: ${escapeHtml(err.message)}</span>`;
  }
}

// ── Term frequency over time ───────────────────────────────────────────────────

let freqMode         = 'term'; // 'term' | 'tag' | 'category'
let freqSelectedTags   = [];   // tag name strings selected in #Tag mode
let freqSelectedCatIds = [];   // category id strings selected in Category mode

const FREQ_PALETTE = [
  '#7986cb','#ef9a9a','#80cbc4','#ffb74d','#a5d6a7',
  '#90caf9','#ce93d8','#f48fb1','#81d4fa','#bcaaa4'
];

function setFreqMode(mode) {
  freqMode = mode;
  document.getElementById('freqModeTermBtn').classList.toggle('active', mode === 'term');
  document.getElementById('freqModeTagBtn').classList.toggle('active',  mode === 'tag');
  document.getElementById('freqModeCatBtn').classList.toggle('active',  mode === 'category');
  const isTerm = mode === 'term';
  document.getElementById('freqInput').style.display    = isTerm ? '' : 'none';
  const chipArea = document.getElementById('freqChipArea');
  chipArea.style.display = isTerm ? 'none' : 'flex';
  if (!isTerm) renderFreqChips();
}

function renderFreqChips() {
  const chipArea = document.getElementById('freqChipArea');
  if (freqMode === 'tag') {
    const allTags = window._lastTagSummary || [];
    chipArea.innerHTML = allTags.map((t, i) => {
      const selIdx = freqSelectedTags.indexOf(t.tag);
      const isSelected = selIdx !== -1;
      const color = isSelected ? FREQ_PALETTE[selIdx % FREQ_PALETTE.length] : '#7986cb';
      return `<span class="freq-chip${isSelected ? ' selected' : ''}"
                    data-tag="${escapeHtml(t.tag)}"
                    style="--chip-color:${color}">${escapeHtml(t.tag)}</span>`;
    }).join('');
  } else {
    chipArea.innerHTML = categoriesData.map(c => {
      const isSelected = freqSelectedCatIds.includes(String(c.id));
      return `<span class="freq-chip${isSelected ? ' selected' : ''}"
                    data-cat-id="${escapeHtml(String(c.id))}"
                    style="--chip-color:${escapeHtml(c.color || '#7986cb')}">
                <span style="color:${escapeHtml(c.color || '#7986cb')}; font-size:0.75rem">●</span>
                ${escapeHtml(c.name)}
              </span>`;
    }).join('');
  }
}

function toggleFreqTag(tag) {
  const idx = freqSelectedTags.indexOf(tag);
  if (idx === -1) freqSelectedTags.push(tag);
  else freqSelectedTags.splice(idx, 1);
  renderFreqChips();
}

function toggleFreqCat(catId) {
  const id = String(catId);
  const idx = freqSelectedCatIds.indexOf(id);
  if (idx === -1) freqSelectedCatIds.push(id);
  else freqSelectedCatIds.splice(idx, 1);
  renderFreqChips();
}

document.getElementById('freqChipArea').addEventListener('click', e => {
  const chip = e.target.closest('.freq-chip');
  if (!chip) return;
  if (chip.dataset.tag)   toggleFreqTag(chip.dataset.tag);
  if (chip.dataset.catId) toggleFreqCat(chip.dataset.catId);
});

document.getElementById('freqBtn').addEventListener('click', runTermFreq);
document.getElementById('freqClearBtn').addEventListener('click', () => {
  freqSelectedTags   = [];
  freqSelectedCatIds = [];
  document.getElementById('freqInput').value = '';
  renderFreqChips();
  document.getElementById('freqResults').innerHTML =
    '<span style="color:#ccc; font-size:0.83rem">Enter a term or select tags/categories to plot frequency per decade.</span>';
  if (freqMode === 'term') document.getElementById('freqInput').focus();
});
document.getElementById('freqInput').addEventListener('keydown', e => {
  if (e.key === 'Enter') runTermFreq();
  if (e.key === 'Escape') document.getElementById('freqClearBtn').click();
});

async function runTermFreq() {
  const results = document.getElementById('freqResults');
  results.innerHTML = '<span style="color:#ccc; font-size:0.83rem">Loading…</span>';

  try {
    let seriesData;  // Array of { data, label, color }

    if (freqMode === 'term') {
      const terms = document.getElementById('freqInput').value
        .split(',').map(t => t.trim()).filter(Boolean);
      if (!terms.length) { results.innerHTML = '<span style="color:#ccc; font-size:0.83rem">Enter at least one term.</span>'; return; }
      const fetches = await Promise.all(
        terms.map(t => fetch(`/api/analysis/termfreq?q=${encodeURIComponent(t)}&mode=term`).then(r => r.json()))
      );
      seriesData = terms.map((t, i) => ({ data: fetches[i], label: t, color: FREQ_PALETTE[i % FREQ_PALETTE.length], mode: 'term' }));

    } else if (freqMode === 'tag') {
      if (!freqSelectedTags.length) {
        results.innerHTML = '<span style="color:#ccc; font-size:0.83rem">Select at least one tag chip above, then click Plot.</span>';
        return;
      }
      const fetches = await Promise.all(
        freqSelectedTags.map(tag => fetch(`/api/analysis/termfreq?q=${encodeURIComponent(tag)}&mode=tag`).then(r => r.json()))
      );
      seriesData = freqSelectedTags.map((tag, i) => ({
        data: fetches[i], label: '#' + tag,
        color: FREQ_PALETTE[i % FREQ_PALETTE.length], mode: 'tag'
      }));

    } else {
      // category mode
      const cats = freqSelectedCatIds
        .map(id => categoriesData.find(c => String(c.id) === id))
        .filter(Boolean);
      if (!cats.length) {
        results.innerHTML = '<span style="color:#ccc; font-size:0.83rem">Select at least one category chip above, then click Plot.</span>';
        return;
      }
      const emptyCats = cats.filter(c => !c.tags.length);
      if (emptyCats.length === cats.length) {
        results.innerHTML = '<span style="color:#ccc; font-size:0.83rem">Selected categories have no tags.</span>';
        return;
      }
      const fetches = await Promise.all(
        cats.map(cat => {
          const tagsParam = cat.tags.map(encodeURIComponent).join(',');
          return fetch(`/api/analysis/termfreq?q=${encodeURIComponent(cat.name)}&mode=category&tags=${tagsParam}`).then(r => r.json());
        })
      );
      seriesData = cats.map((cat, i) => ({
        data: fetches[i], label: cat.name,
        color: cat.color || FREQ_PALETTE[i % FREQ_PALETTE.length], mode: 'category'
      }));
    }

    // Filter out fully-empty series
    seriesData = seriesData.filter(s => s.data.length > 0);
    if (!seriesData.length) {
      results.innerHTML = '<span style="color:#ccc; font-size:0.83rem">No dated documents in corpus.</span>';
      return;
    }

    // Align all series to a common bucket list
    const allBuckets = [...new Set(seriesData.flatMap(s => s.data.map(d => d.bucket)))]
      .sort((a, b) => parseInt(a) - parseInt(b));

    const aligned = seriesData.map(s => {
      const map = new Map(s.data.map(d => [d.bucket, d]));
      return allBuckets.map(b => map.get(b) ?? { bucket: b, occurrences: 0, doc_count: 0, total_docs: 0 });
    });

    const N = seriesData.length;
    const M = allBuckets.length;
    const globalMaxOcc = Math.max(...aligned.flat().map(d => d.occurrences), 1);

    // SVG layout
    const W = 600, H = 200, padL = 32, padR = 10, padT = 14, padB = 52;
    const plotW = W - padL - padR;
    const plotH = H - padT - padB;
    const slot  = plotW / M;
    const seriesBarW = Math.min(32 / Math.max(N, 1), Math.max(3, (slot * 0.72 - 1.5 * (N - 1)) / N));

    const barsSvg = allBuckets.map((bucket, i) => {
      const cx     = padL + (i + 0.5) * slot;
      const labelY = (padT + plotH + 13).toFixed(1);
      const label  = `<text x="${cx.toFixed(1)}" y="${labelY}"
                            text-anchor="end" font-size="9" fill="#bbb"
                            transform="rotate(-45,${cx.toFixed(1)},${labelY})">${bucket}</text>`;
      const bars = seriesData.map((s, j) => {
        const d      = aligned[j][i];
        const offset = (j - (N - 1) / 2) * (seriesBarW + 1.5);
        const barX   = (cx + offset - seriesBarW / 2).toFixed(1);
        const bh     = d.occurrences / globalMaxOcc * plotH;
        const y      = (padT + plotH - bh).toFixed(1);
        const col    = d.occurrences > 0 ? s.color : '#eef0f5';
        return `<rect x="${barX}" y="${y}" width="${seriesBarW.toFixed(1)}" height="${Math.max(1, bh).toFixed(1)}"
                      fill="${col}" rx="2"/>
                ${d.occurrences > 0 && seriesBarW > 10
                  ? `<text x="${(cx + offset).toFixed(1)}" y="${(padT + plotH - bh - 3).toFixed(1)}"
                           text-anchor="middle" font-size="7" fill="${s.color}">${d.occurrences}</text>`
                  : ''}`;
      }).join('');
      return label + bars;
    }).join('');

    const axisY = padT + plotH;

    // Legend
    const legendItems = seriesData.map((s, j) => {
      const total   = aligned[j].reduce((acc, d) => acc + d.occurrences, 0);
      const docHits = aligned[j].reduce((acc, d) => acc + d.doc_count, 0);
      const detail  = s.mode === 'term'
        ? `${total} occ. in ${docHits} doc${docHits !== 1 ? 's' : ''}`
        : `${total} doc${total !== 1 ? 's' : ''} matched`;
      return `<span style="display:inline-flex; align-items:center; gap:0.3rem; margin-right:0.9rem; font-size:0.72rem; color:#666">
                <span style="width:10px; height:10px; border-radius:2px; background:${s.color}; flex-shrink:0; display:inline-block"></span>
                <strong style="color:${s.color}">${escapeHtml(s.label)}</strong>
                <span style="color:#bbb">${detail}</span>
              </span>`;
    }).join('');

    const barDesc = freqMode === 'term' ? 'bar height = occurrence count per decade'
                                        : 'bar height = documents matched per decade';
    results.innerHTML = `
      <svg width="100%" viewBox="0 0 ${W} ${H}" style="overflow:visible; display:block">
        <line x1="${padL}" y1="${axisY}" x2="${W - padR}" y2="${axisY}"
              stroke="#dde1ea" stroke-width="1"/>
        ${barsSvg}
      </svg>
      <div style="display:flex; flex-wrap:wrap; margin-top:0.45rem; padding-left:${padL}px">
        ${legendItems}
      </div>
      <div style="font-size:0.71rem; color:#bbb; margin-top:0.3rem; padding-left:${padL}px">${barDesc}</div>`;
  } catch (err) {
    results.innerHTML = `<span class="error" style="font-size:0.82rem">Error: ${escapeHtml(err.message)}</span>`;
  }
}

// ── Boolean tag filter ────────────────────────────────────────────────────────

function parseBoolFilter(expr) {
  // Tokenize operators (AND/OR/NOT) and #tag references
  const tokens = [];
  const re = /(AND|OR|NOT|#[\w-]+)/gi;
  let m;
  while ((m = re.exec(expr)) !== null) {
    const v = m[1];
    if (/^(AND|OR|NOT)$/i.test(v)) tokens.push({ type: 'op', value: v.toUpperCase() });
    else tokens.push({ type: 'tag', value: v.slice(1).toLowerCase() });
  }
  if (!tokens.length) return null;
  const terms = [];
  let pendingOp = 'AND';
  for (const tok of tokens) {
    if (tok.type === 'op') { pendingOp = tok.value; }
    else { terms.push({ op: pendingOp, tag: tok.value }); pendingOp = 'AND'; }
  }
  return terms.length ? terms : null;
}

function applyBoolFilter(docs, terms) {
  if (!terms || !terms.length) return docs;
  const hasTag = (doc, tag) => parseTags(doc.tags).some(t => t.toLowerCase() === tag);
  const byId = new Map(docs.map(d => [d.id, d]));
  let result = new Set(
    docs.filter(doc => hasTag(doc, terms[0].tag)).map(d => d.id)
  );
  for (let i = 1; i < terms.length; i++) {
    const { op, tag } = terms[i];
    if (op === 'AND') {
      for (const id of [...result]) {
        const doc = byId.get(id);
        if (!doc || !hasTag(doc, tag)) result.delete(id);
      }
    } else if (op === 'OR') {
      docs.filter(d => hasTag(d, tag)).forEach(d => result.add(d.id));
    } else if (op === 'NOT') {
      docs.filter(d => hasTag(d, tag)).forEach(d => result.delete(d.id));
    }
  }
  return docs.filter(d => result.has(d.id));
}

function applyBoolFilterFromInput() {
  const expr = document.getElementById('boolFilterInput').value.trim();
  if (!expr) { clearFilter(); return; }
  const terms = parseBoolFilter(expr);
  if (!terms) return;
  activeBoolFilter  = terms;
  activeTagFilter   = null;
  activeSearchQuery = null;
  document.getElementById('searchInput').value = '';
  updateFilterBar();
  loadDocuments();
}

document.getElementById('boolFilterBtn').addEventListener('click', applyBoolFilterFromInput);
document.getElementById('boolFilterInput').addEventListener('keydown', e => {
  if (e.key === 'Enter') applyBoolFilterFromInput();
  if (e.key === 'Escape') clearFilter();
});

// ── Tag co-occurrence ─────────────────────────────────────────────────────────

async function loadCooccurrence() {
  const container = document.getElementById('coocResults');
  container.innerHTML = '<span style="color:#ccc; font-size:0.83rem">Loading…</span>';
  try {
    const pairs = await fetch('/api/analysis/cooccurrence').then(r => r.json());
    if (!pairs.length) {
      container.innerHTML = '<span style="color:#ccc; font-size:0.83rem">No co-occurring tags yet. Tag multiple concepts per document to see pairs here.</span>';
      return;
    }
    const max = pairs[0].count;
    container.innerHTML = `
      <div style="font-size:0.72rem; color:#bbb; margin-bottom:0.55rem">${pairs.length} tag pair${pairs.length !== 1 ? 's' : ''} across corpus</div>
      ${pairs.map(p => {
        const pct   = Math.max(3, Math.round(p.count / max * 100));
        const colA  = tagColor(p.tag_a);
        const colB  = tagColor(p.tag_b);
        return `
          <div style="display:flex; align-items:center; gap:0.6rem; margin-bottom:0.35rem">
            <div style="font-size:0.78rem; color:#444; white-space:nowrap; flex:0 0 auto">
              <span style="background:${colA}; border-radius:3px; padding:1px 5px">#${escapeHtml(p.tag_a)}</span>
              <span style="color:#ccc; margin:0 0.2rem">×</span>
              <span style="background:${colB}; border-radius:3px; padding:1px 5px">#${escapeHtml(p.tag_b)}</span>
            </div>
            <div style="flex:1; height:4px; background:#eef0f5; border-radius:3px; overflow:hidden; min-width:0">
              <div style="width:${pct}%; height:100%; background:#9fa8da; border-radius:3px"></div>
            </div>
            <span style="font-size:0.72rem; color:#bbb; flex-shrink:0">${p.count}</span>
          </div>`;
      }).join('')}`;
  } catch (err) {
    container.innerHTML = `<span class="error" style="font-size:0.82rem">Error: ${escapeHtml(err.message)}</span>`;
  }
}

// ── Document timeline ─────────────────────────────────────────────────────────

async function loadTimeline() {
  const container = document.getElementById('timelineResults');
  container.innerHTML = '<span style="color:#ccc; font-size:0.83rem">Loading…</span>';
  try {
    const docs = await fetch('/api/analysis/timeline').then(r => r.json());
    if (!docs.length) {
      container.innerHTML = '<span style="color:#ccc; font-size:0.83rem">No dated documents in corpus. Add publication dates to enable the timeline.</span>';
      return;
    }

    timelineDocs = {};
    docs.forEach(d => { timelineDocs[d.id] = d; });

    const getYear = d => parseInt((d.publication_date || '').slice(0, 4), 10);
    const validDocs = docs.filter(d => !isNaN(getYear(d)));
    if (!validDocs.length) {
      container.innerHTML = '<span style="color:#ccc; font-size:0.83rem">No documents with parseable publication years.</span>';
      return;
    }

    const years  = validDocs.map(getYear);
    const minY   = Math.min(...years), maxY = Math.max(...years);
    const range  = maxY - minY || 1;
    const maxAnn = Math.max(...docs.map(d => d.annotation_count), 1);

    const W = 640, H = 180, padL = 36, padR = 14, padT = 16, padB = 26;
    const plotW = W - padL - padR;
    const plotH = H - padT - padB;
    const midY  = padT + plotH / 2;

    function xFor(y) { return padL + (y - minY) / range * plotW; }
    function rFor(n) { return 5 + Math.sqrt(n / maxAnn) * 11; }
    function yJitter(id) {
      let h = 0;
      for (const c of id) { h = ((h << 5) - h) + c.charCodeAt(0); h |= 0; }
      return (Math.abs(h) % 36) - 18;
    }

    const tickStep  = range <= 10 ? 1 : range <= 50 ? 5 : range <= 150 ? 10 : 25;
    const firstTick = Math.ceil(minY / tickStep) * tickStep;
    const ticks     = [];
    for (let y = firstTick; y <= maxY; y += tickStep) ticks.push(y);

    const axisY   = padT + plotH;
    const tickSvg = ticks.map(y => {
      const x = xFor(y).toFixed(1);
      return `<line x1="${x}" y1="${axisY}" x2="${x}" y2="${axisY + 4}" stroke="#dde1ea" stroke-width="1"/>
              <text x="${x}" y="${axisY + 14}" text-anchor="middle" font-size="9" fill="#bbb">${y}</text>`;
    }).join('');

    const circleSvg = validDocs.map(d => {
      const cx  = xFor(getYear(d)).toFixed(1);
      const cy  = (midY + yJitter(d.id)).toFixed(1);
      const r   = rFor(d.annotation_count).toFixed(1);
      const col = tagColor(d.dominant_tag).replace('0.55)', '0.82)');
      return `<circle class="tl-dot" cx="${cx}" cy="${cy}" r="${r}"
                      fill="${col}" stroke="white" stroke-width="1.5"
                      data-doc-id="${escapeHtml(d.id)}" style="cursor:pointer"/>`;
    }).join('');

    container.innerHTML = `
      <div style="position:relative">
        <svg width="100%" viewBox="0 0 ${W} ${H}" style="overflow:visible; display:block">
          <line x1="${padL}" y1="${axisY}" x2="${W - padR}" y2="${axisY}" stroke="#dde1ea" stroke-width="1"/>
          ${tickSvg}
          ${circleSvg}
        </svg>
        <div id="timelineTip"
             style="display:none; position:absolute; background:white; border:1px solid #dde1ea;
                    border-radius:6px; padding:0.45rem 0.65rem; font-size:0.78rem; color:#333;
                    pointer-events:none; box-shadow:0 2px 8px rgba(0,0,0,0.1);
                    max-width:200px; z-index:10; line-height:1.45"></div>
      </div>
      <div style="font-size:0.71rem; color:#bbb; margin-top:0.35rem; padding-left:${padL}px">
        ${validDocs.length} document${validDocs.length !== 1 ? 's' : ''}
        · dot size = annotation count
        ${maxY > minY ? ` · ${minY}–${maxY}` : ''}
      </div>`;

    // Attach hover/click after DOM insertion
    container.querySelectorAll('.tl-dot').forEach(dot => {
      dot.addEventListener('mouseenter', e => {
        const d   = timelineDocs[dot.getAttribute('data-doc-id')];
        const tip = document.getElementById('timelineTip');
        if (!d || !tip) return;
        tip.innerHTML = `
          <strong style="display:block; font-size:0.8rem; margin-bottom:0.15rem">${escapeHtml(d.title)}</strong>
          <div style="color:#aaa">${escapeHtml(d.publication_date || '?')}</div>
          ${d.annotation_count
            ? `<div style="color:#7986cb; margin-top:0.1rem">${d.annotation_count} annotation${d.annotation_count !== 1 ? 's' : ''}</div>`
            : '<div style="color:#ccc">no annotations</div>'}
          ${d.dominant_tag ? `<div style="color:#bbb; font-size:0.71rem; margin-top:0.1rem">#${escapeHtml(d.dominant_tag)}</div>` : ''}`;
        tip.style.display = 'block';
        positionTimelineTip(e);
      });
      dot.addEventListener('mousemove', e => positionTimelineTip(e));
      dot.addEventListener('mouseleave', () => {
        const tip = document.getElementById('timelineTip');
        if (tip) tip.style.display = 'none';
      });
      dot.addEventListener('click', () => {
        switchTab('document');
        viewDocument(dot.getAttribute('data-doc-id'));
      });
    });

  } catch (err) {
    container.innerHTML = `<span class="error" style="font-size:0.82rem">Error: ${escapeHtml(err.message)}</span>`;
  }
}

function positionTimelineTip(e) {
  const tip = document.getElementById('timelineTip');
  if (!tip) return;
  const rect = tip.parentElement.getBoundingClientRect();
  let x = e.clientX - rect.left + 14;
  let y = e.clientY - rect.top  - 10;
  if (x + 210 > rect.width) x = e.clientX - rect.left - 215;
  if (y < 0) y = 4;
  tip.style.left = x + 'px';
  tip.style.top  = y + 'px';
}

// ── Boot ──────────────────────────────────────────────────────────────────────

loadDocuments();
loadTagSummary();
pollSyncStatus();

</script>
</body>
</html>
