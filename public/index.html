<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Keel-MCP | Corpus Manager</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      margin: 0;
      padding: 0;
      background: #f0f2f5;
      color: #1a1a2e;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 2px solid #dde1ea;
      padding: 0.7rem 1.5rem;
      flex-shrink: 0;
    }
    h1 { margin: 0; font-size: 1.4rem; color: #1a1a2e; }
    h1 span { color: #5c6bc0; }
    h2 { margin: 0 0 1.2rem; font-size: 1.05rem; color: #333; }

    /* â”€â”€ Three-column workspace â”€â”€ */
    .workspace {
      display: grid;
      grid-template-columns: 300px 1fr 1fr;
      gap: 1rem;
      flex: 1;
      min-height: 0;
      padding: 1rem 1.5rem;
      overflow: hidden;
    }
    .col-tools {
      overflow-y: auto;
      min-height: 0;
    }
    .col-review, .col-viewer {
      overflow-y: hidden;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }
    .review-card, .viewer-card {
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
      margin-bottom: 0;
    }
    .review-card-top, .viewer-card-top { flex-shrink: 0; }
    #reviewQueue {
      flex: 1;
      overflow-y: auto;
      min-height: 0;
    }
    #viewerContent {
      flex: 1;
      overflow-y: auto;
      min-height: 0;
      font-size: 0.9rem;
      line-height: 1.75;
    }
    .viewer-placeholder {
      color: #aaa;
      text-align: center;
      padding: 3rem 1rem;
      font-size: 0.9rem;
    }
    .viewer-doc-header {
      border-bottom: 1px solid #eef0f5;
      padding-bottom: 0.8rem;
      margin-bottom: 1rem;
    }
    .viewer-body {
      white-space: pre-wrap;
      word-break: break-word;
      color: #333;
      font-size: 0.88rem;
      line-height: 1.75;
    }
    .viewer-body mark {
      background: #fff176;
      border-radius: 2px;
      padding: 0 2px;
    }

    /* â”€â”€ Model preset buttons â”€â”€ */
    .btn-preset {
      font-size: 0.8rem;
      padding: 0.2rem 0.7rem;
      background: #f0f0f0;
      color: #333;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 400;
    }
    .btn-preset:hover { background: #e0e0e0; color: #111; }

    .card {
      background: white;
      padding: 1.5rem;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.07);
      margin-bottom: 1rem;
    }

    /* â”€â”€ Upload â”€â”€ */
    .upload-area {
      border: 2px dashed #c5cae9;
      padding: 2.5rem 2rem;
      text-align: center;
      border-radius: 8px;
      cursor: pointer;
      transition: border-color .2s, background .2s;
      background: #fafbff;
    }
    .upload-area:hover, .upload-area.dragover {
      border-color: #5c6bc0;
      background: #eef0fb;
    }
    .upload-area p { margin: 0.3rem 0; color: #666; font-size: 0.95rem; }
    .upload-area .hint { font-size: 0.82rem; color: #aaa; margin-top: 0.5rem; }
    #fileName { font-weight: 600; color: #5c6bc0; min-height: 1.2rem; margin-top: 0.6rem; }

    .meta-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1rem 0; }
    label { font-size: 0.85rem; color: #555; display: block; margin-bottom: 0.2rem; }
    input[type="text"], input[type="date"] {
      width: 100%;
      padding: 0.5rem 0.7rem;
      border: 1px solid #dde1ea;
      border-radius: 6px;
      font-size: 0.95rem;
      background: #fafbff;
    }
    input:focus { outline: 2px solid #5c6bc0; border-color: transparent; }

    button {
      background: #5c6bc0;
      color: white;
      border: none;
      padding: 0.65rem 1.4rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 500;
      transition: background .15s;
    }
    button:hover { background: #3f51b5; }
    button:disabled { background: #b0bec5; cursor: not-allowed; }
    button.danger { background: #e53935; }
    button.danger:hover { background: #c62828; }

    #uploadStatus { margin-top: 0.8rem; font-size: 0.9rem; font-weight: 500; }
    .success { color: #2e7d32; }
    .error   { color: #c62828; }

    /* â”€â”€ Search â”€â”€ */
    .search-row { display: flex; gap: 0.6rem; }
    .search-row input { flex: 1; }
    .search-hint { font-size: 0.8rem; color: #aaa; margin-top: 0.5rem; }

    #searchResults { margin-top: 1rem; }
    .search-result {
      padding: 0.9rem 0;
      border-bottom: 1px solid #eef0f5;
    }
    .search-result:last-child { border-bottom: none; }
    .search-result strong { color: #1a1a2e; }
    .search-result .meta { font-size: 0.82rem; color: #888; margin: 0.2rem 0; }
    .search-result .snippet {
      font-size: 0.88rem;
      color: #444;
      margin-top: 0.4rem;
      line-height: 1.5;
    }
    .search-result .snippet mark {
      background: #fff176;
      color: #1a1a2e;
      border-radius: 2px;
      padding: 0 1px;
    }

    /* â”€â”€ Corpus library â”€â”€ */
    .doc-list { list-style: none; padding: 0; margin: 0; }
    .doc-item {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 0.9rem 0;
      border-bottom: 1px solid #eef0f5;
      gap: 1rem;
    }
    .doc-item:last-child { border-bottom: none; }
    .doc-meta { font-size: 0.82rem; color: #888; margin-top: 0.25rem; }
    .badge {
      background: #e8eaf6;
      color: #3f51b5;
      padding: 0.15rem 0.5rem;
      border-radius: 4px;
      font-size: 0.75rem;
      margin-right: 0.3rem;
    }
    .badge.annotation { background: #fff3e0; color: #e65100; }
    .doc-id { font-family: monospace; font-size: 0.68rem; color: #ccc; margin-top: 0.3rem; }

    /* â”€â”€ Annotation panel â”€â”€ */
    .annotation-panel {
      border-top: 1px solid #eef0f5;
      margin-top: 0.8rem;
      padding-top: 0.8rem;
      display: none;
    }
    .annotation-panel.open { display: block; }
    .annotation-list { list-style: none; padding: 0; margin: 0 0 0.8rem; }
    .ann-item {
      padding: 0.6rem 0.8rem;
      border-radius: 6px;
      margin-bottom: 0.5rem;
      font-size: 0.87rem;
      line-height: 1.5;
    }
    .ann-item.llm   { background: #e8eaf6; border-left: 3px solid #5c6bc0; }
    .ann-item.human { background: #e8f5e9; border-left: 3px solid #43a047; }
    .ann-meta { font-size: 0.75rem; color: #888; margin-top: 0.25rem; }
    .ann-tag  { background: white; border-radius: 4px; padding: 0.1rem 0.4rem; font-size: 0.72rem; margin-right: 0.3rem; }
    .ann-corrects { font-style: italic; color: #aaa; font-size: 0.75rem; }
    .ann-delete { float: right; background: none; border: none; color: #e57373; cursor: pointer; font-size: 0.8rem; padding: 0; }
    .ann-delete:hover { color: #c62828; background: none; }

    .add-ann-form { display: flex; flex-direction: column; gap: 0.5rem; }
    .add-ann-form input { font-size: 0.88rem; }
    .add-ann-form textarea { padding: 0.5rem 0.7rem; border: 1px solid #dde1ea; border-radius: 6px; font-size: 0.88rem; resize: vertical; min-height: 60px; font-family: inherit; }
    .add-ann-row { display: flex; gap: 0.5rem; }
    .add-ann-row input { flex: 1; }
    .btn-sm { padding: 0.4rem 0.9rem; font-size: 0.85rem; }

    /* â”€â”€ Activity panel â”€â”€ */
    .activity-panel {
      background: #1a1a2e;
      color: #e0e0e0;
      border-radius: 10px;
      padding: 1.2rem 1.5rem;
      font-family: 'SF Mono', 'Fira Code', 'Fira Mono', monospace;
      font-size: 0.82rem;
      line-height: 1.6;
      max-height: 400px;
      overflow-y: auto;
      margin-bottom: 1.5rem;
    }
    .activity-panel h2 { color: #90caf9; font-family: system-ui; margin-bottom: 1rem; }

    .log-entry { margin-bottom: 1rem; border-bottom: 1px solid #2d2d4e; padding-bottom: 0.8rem; }
    .log-entry:last-child { border-bottom: none; margin-bottom: 0; }

    .log-time    { color: #78909c; }
    .log-tool    { font-weight: 700; }
    .log-tool.search   { color: #64b5f6; }
    .log-tool.analyze  { color: #ce93d8; }
    .log-tool.annotate { color: #ffb74d; }
    .log-tool.memory   { color: #a5d6a7; }
    .log-tool.default  { color: #80cbc4; }

    .log-summary { color: #b0bec5; margin-top: 0.15rem; }
    .log-sql {
      margin-top: 0.3rem;
      color: #546e7a;
      font-size: 0.77rem;
      white-space: pre-wrap;
      word-break: break-all;
    }
    .log-sql::before { content: 'SQL â–¸ '; color: #37474f; }

    .empty-log { color: #546e7a; font-style: italic; }

    /* â”€â”€ Batch annotate â”€â”€ */
    .batch-controls { display: flex; align-items: center; gap: 0.8rem; flex-wrap: wrap; margin-top: 0.9rem; }
    .batch-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
    .batch-status { font-size: 0.85rem; color: #888; }
    .batch-progress-area { margin-top: 1rem; display: none; }
    .batch-progress-area.active { display: block; }
    .batch-progress-bar { width: 100%; height: 6px; border-radius: 3px; accent-color: #5c6bc0; margin-bottom: 0.5rem; }
    .batch-doc-title { font-size: 0.85rem; color: #555; margin-bottom: 0.4rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .batch-counters { font-size: 0.82rem; color: #666; }
    .batch-counters .ok  { color: #2e7d32; }
    .batch-counters .sk  { color: #5c6bc0; }
    .batch-counters .err { color: #c62828; }
    button.stop { background: #546e7a; }
    button.stop:hover { background: #37474f; }

    /* â”€â”€ Review Mode â”€â”€ */
    .review-item {
      border: 1px solid #e8eaf6;
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 0.8rem;
      background: #fafbff;
      transition: opacity 0.15s;
    }
    .review-item-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      flex-wrap: wrap;
    }
    .review-doc-title {
      font-size: 0.88rem;
      font-weight: 600;
      color: #1a1a2e;
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .review-item-text {
      font-size: 0.9rem;
      line-height: 1.55;
      color: #333;
      margin-bottom: 0.8rem;
      white-space: pre-wrap;
    }
    .review-actions { display: flex; gap: 0.5rem; flex-wrap: wrap; }
    .btn-accept { background: #388e3c; }
    .btn-accept:hover { background: #1b5e20; }
    .btn-edit-open { background: #546e7a; }
    .btn-edit-open:hover { background: #37474f; }
    .edit-textarea {
      width: 100%;
      padding: 0.5rem 0.7rem;
      border: 1px solid #dde1ea;
      border-radius: 6px;
      font-size: 0.88rem;
      font-family: inherit;
      resize: vertical;
      min-height: 80px;
      background: #fff;
    }
  </style>
</head>
<body>

<header>
  <h1>Keel<span>-MCP</span> Â· Corpus Manager</h1>
  <div style="display:flex; align-items:center; gap:0.8rem">
    <span id="syncStatusBadge" style="font-size:0.8rem; color:#aaa"></span>
    <button id="syncBtn" style="padding:0.4rem 0.9rem; font-size:0.85rem" onclick="triggerSync()">â†‘â†“ Sync</button>
    <a href="/api/documents" target="_blank" style="font-size:0.85rem; color:#5c6bc0; text-decoration:none;">Raw API â†—</a>
    <button class="danger" id="deleteAllBtn" style="padding:0.4rem 0.9rem; font-size:0.85rem">Delete All</button>
  </div>
</header>

<div class="workspace">
<div class="col-tools">

<!-- Upload -->
<div class="card">
  <h2>Upload Corpus</h2>
  <form id="uploadForm">
    <div class="upload-area" id="dropZone">
      <p>Drop a <strong>folder</strong> or select files</p>
      <p class="hint">Accepts .md and .txt Â· drag a whole folder to import in bulk</p>
      <input type="file" id="fileInput" name="files" style="display:none" multiple accept=".md,.txt,text/plain,text/markdown">
      <div id="fileName"></div>
    </div>

    <div class="meta-grid">
      <div>
        <label>Author <span style="color:#aaa">(applied to all files)</span></label>
        <input type="text" name="author" placeholder="e.g. Eduard Hanslick">
      </div>
      <div>
        <label>Publication Date</label>
        <input type="date" name="publication_date">
      </div>
    </div>

    <label>Tags <span style="color:#aaa">(comma-separated)</span></label>
    <input type="text" name="tags" placeholder="music criticism, romanticism, 19th century" style="margin-bottom:1rem">

    <button type="submit" id="submitBtn">Upload Documents</button>
    <div id="uploadStatus"></div>
  </form>
</div>

<!-- Search -->
<div class="card">
  <h2>Search Corpus</h2>
  <div class="search-row">
    <input type="text" id="searchInput" placeholder='e.g.  sublime   "nature metaphor"   Kant AND beauty'>
    <button type="button" id="searchBtn">Search</button>
  </div>
  <p class="search-hint">
    FTS5 syntax: phrases in quotes Â· AND / OR / NOT Â· prefix wildcard <code>philos*</code>
  </p>
  <div id="searchResults"></div>
</div>

<!-- Ask the AI -->
<div class="card">
  <h2>Ask the AI</h2>
  <p style="color:#666; font-size:0.9rem; margin:-0.4rem 0 1.1rem">Ask a free-form research question. The model searches and reads the corpus using any tools it needs, then returns an answer and writes targeted annotations â€” useful for exploratory, open-ended queries.</p>

  <label>System prompt</label>
  <textarea id="systemPrompt" rows="4" style="width:100%; padding:0.5rem 0.7rem; border:1px solid #dde1ea; border-radius:6px; font-size:0.85rem; font-family:inherit; resize:vertical; margin-bottom:0.9rem; background:#fafbff;">You are a musicology research assistant. Use the available tools to analyse the corpus. When you find a relevant passage, write an annotation with a concise tag. The corpus is in German. Write every annotation in German. Do not translate. Do not use English. IMPORTANT: Always use document IDs returned by search_corpus or read_corpus. Never invent or guess a document ID. If search_corpus returns no results, try a shorter or simpler keyword (1â€“2 words maximum). Do not use full sentences or phrases as search queries.</textarea>

  <label>Your question</label>
  <textarea id="userMessage" rows="2" placeholder="e.g. Search for 'erhaben' and annotate the three most significant passages." style="width:100%; padding:0.5rem 0.7rem; border:1px solid #dde1ea; border-radius:6px; font-size:0.9rem; font-family:inherit; resize:vertical; margin-bottom:0.9rem; background:#fafbff;"></textarea>

  <div style="display:flex; gap:0.5rem; margin-bottom:0.6rem; flex-wrap:wrap">
    <button onclick="setPreset('run','ollama')" class="btn-preset">Ollama (local)</button>
    <button onclick="setPreset('run','claude')" class="btn-preset">Claude (Anthropic)</button>
    <button onclick="setPreset('run','openai')" class="btn-preset">OpenAI</button>
  </div>

  <div style="display:flex; align-items:center; gap:1rem; flex-wrap:wrap">
    <div style="display:flex; align-items:center; gap:0.5rem">
      <label style="margin:0; white-space:nowrap">Model</label>
      <input type="text" id="modelName" value="qwen2.5:7b" style="width:220px" list="ollamaModels">
    </div>
    <div style="display:flex; align-items:center; gap:0.5rem">
      <label style="margin:0; white-space:nowrap">Endpoint</label>
      <input type="text" id="runEndpoint" value="http://localhost:11434/v1/chat/completions" style="width:300px" placeholder="API base URL">
    </div>
    <div style="display:flex; align-items:center; gap:0.5rem">
      <label style="margin:0; white-space:nowrap">API key</label>
      <input type="password" id="runApiKey" placeholder="sk-â€¦ (leave blank for Ollama)" style="width:200px">
    </div>
    <button id="runBtn" onclick="runQuery()">â–¶ Run</button>
    <span id="runStatus" style="font-size:0.85rem; color:#888"></span>
  </div>

  <div id="runOutput" class="activity-panel" style="display:none; margin-top:1.2rem; margin-bottom:0"></div>
</div>

<!-- Batch Annotate -->
<div class="card">
  <h2>Batch Annotate</h2>
  <p style="color:#666; font-size:0.9rem; margin:-0.4rem 0 1.1rem">Apply one analytical concept to <em>every</em> document in the corpus in a single run. The model calls <code>analyze_document</code> and <code>annotate_document</code> on each document in sequence â€” useful for systematic, reproducible analysis across an entire collection.</p>

  <div class="batch-grid">
    <div>
      <label>Concept <span style="color:#aaa">(what to look for)</span></label>
      <input type="text" id="batchConcept" placeholder="e.g. das Erhabene, Natur, Harmonie">
    </div>
    <div>
      <label>Tag <span style="color:#aaa">(applied to annotations)</span></label>
      <input type="text" id="batchTag" placeholder="e.g. kantian-sublime">
    </div>
  </div>

  <div style="display:flex; gap:0.5rem; margin-top:1rem; flex-wrap:wrap">
    <button onclick="setPreset('batch','ollama')" class="btn-preset">Ollama (local)</button>
    <button onclick="setPreset('batch','claude')" class="btn-preset">Claude (Anthropic)</button>
    <button onclick="setPreset('batch','openai')" class="btn-preset">OpenAI</button>
  </div>

  <div style="display:flex; align-items:center; gap:1rem; flex-wrap:wrap; margin-top:0.6rem">
    <div style="display:flex; align-items:center; gap:0.5rem">
      <label style="margin:0; white-space:nowrap">Model</label>
      <input type="text" id="batchModel" value="qwen2.5:7b" style="width:220px" list="ollamaModels">
    </div>
    <div style="display:flex; align-items:center; gap:0.5rem">
      <label style="margin:0; white-space:nowrap">Endpoint</label>
      <input type="text" id="batchEndpoint" value="http://localhost:11434/v1/chat/completions" style="width:300px" placeholder="API base URL">
    </div>
    <div style="display:flex; align-items:center; gap:0.5rem">
      <label style="margin:0; white-space:nowrap">API key</label>
      <input type="password" id="batchApiKey" placeholder="sk-â€¦ (leave blank for Ollama)" style="width:200px">
    </div>
    <div style="display:flex; align-items:center; gap:0.5rem">
      <input type="checkbox" id="batchResume" checked style="width:auto">
      <label for="batchResume" style="margin:0; font-size:0.88rem">Skip docs already annotated with this tag</label>
    </div>
    <div style="display:flex; align-items:center; gap:0.5rem">
      <label style="margin:0; white-space:nowrap; font-size:0.88rem">Delay</label>
      <input type="range" id="batchDelay" min="0" max="2000" step="100" value="500" style="width:120px">
      <span id="batchDelayLabel" style="font-size:0.85rem; color:#888; min-width:3rem">500 ms</span>
    </div>
  </div>

  <div class="batch-controls">
    <button id="batchRunBtn" onclick="batchRun()">â–¶ Batch Run</button>
    <button id="batchStopBtn" class="stop" style="display:none" onclick="batchStop()">â–  Stop</button>
    <span id="batchStatus" class="batch-status"></span>
  </div>

  <div class="batch-progress-area" id="batchProgressArea">
    <progress class="batch-progress-bar" id="batchProgressBar" value="0" max="100"></progress>
    <div class="batch-doc-title" id="batchDocTitle"></div>
    <div class="batch-counters">
      <span class="ok" id="batchAnnotated">âœ“ 0 annotated</span> Â·
      <span class="sk" id="batchSkipped">âŸ² 0 skipped</span> Â·
      <span class="err" id="batchErrors">âœ— 0 errors</span>
    </div>
  </div>

  <div id="batchOutput" class="activity-panel" style="display:none; margin-top:1.2rem; margin-bottom:0"></div>
</div>

<!-- Connect your LLM -->
<details style="margin-bottom:1rem">
<summary style="cursor:pointer; font-size:0.85rem; color:#888; user-select:none; list-style:none; display:flex; align-items:center; gap:0.4rem">
  <span>â–¸</span> Developer options â€” MCP &amp; REST connection info
</summary>
<div class="card" style="margin-top:0.6rem; margin-bottom:0">
  <h2>Connect a Local LLM</h2>
  <p style="color:#555; font-size:0.92rem; margin-bottom:1rem">
    The MCP server is also reachable over SSE â€” connect any local model to the same corpus tools Claude uses.
  </p>
  <div style="display:grid; grid-template-columns:1fr 1fr; gap:1rem">

    <div style="background:#f5f7ff; border-radius:8px; padding:1rem">
      <strong style="font-size:0.9rem">Open WebUI / AnythingLLM</strong>
      <p style="font-size:0.82rem; color:#555; margin:0.5rem 0">Settings â†’ MCP Servers â†’ Add server</p>
      <code style="font-size:0.8rem; background:#e8eaf6; padding:0.4rem 0.6rem; border-radius:4px; display:block; word-break:break-all">
        http://localhost:3000/mcp/sse
      </code>
    </div>

    <div style="background:#f5f7ff; border-radius:8px; padding:1rem">
      <strong style="font-size:0.9rem">Continue.dev (VS Code)</strong>
      <p style="font-size:0.82rem; color:#555; margin:0.5rem 0">Add to <code>~/.continue/config.json</code></p>
      <pre style="font-size:0.75rem; background:#e8eaf6; padding:0.4rem 0.6rem; border-radius:4px; margin:0; overflow-x:auto">{
  "mcpServers": [{
    "name": "keel-mcp",
    "transport": "sse",
    "url": "http://localhost:3000/mcp/sse"
  }]
}</pre>
    </div>

    <div style="background:#f5f7ff; border-radius:8px; padding:1rem">
      <strong style="font-size:0.9rem">Claude Desktop (stdio)</strong>
      <p style="font-size:0.82rem; color:#555; margin:0.5rem 0">Add to <code>claude_desktop_config.json</code></p>
      <pre style="font-size:0.75rem; background:#e8eaf6; padding:0.4rem 0.6rem; border-radius:4px; margin:0; overflow-x:auto">{
  "mcpServers": {
    "keel-mcp": {
      "command": "node",
      "args": ["--import","tsx",
        "/path/to/keel-mcp/src/server.ts"]
    }
  }
}</pre>
    </div>

    <div style="background:#f5f7ff; border-radius:8px; padding:1rem">
      <strong style="font-size:0.9rem">OpenAI-compatible REST <span style="background:#e8f5e9; color:#2e7d32; border-radius:4px; padding:0.1rem 0.4rem; font-size:0.7rem; font-weight:700">UNIVERSAL</span></strong>
      <p style="font-size:0.82rem; color:#555; margin:0.5rem 0">Works with Ollama, Claude API, Gemini, LiteLLM â€” no MCP client needed</p>
      <code style="font-size:0.8rem; background:#e8eaf6; padding:0.4rem 0.6rem; border-radius:4px; display:block; margin-bottom:0.3rem">GET  /api/tools         â†’ tool schema</code>
      <code style="font-size:0.8rem; background:#e8eaf6; padding:0.4rem 0.6rem; border-radius:4px; display:block">POST /api/tools/call    â†’ { name, arguments }</code>
    </div>

  </div>
</div>
</details>

<!-- Agent Activity -->
<div class="activity-panel" id="activityPanel">
  <h2>Live Agent Activity</h2>
  <div id="activityLog"><span class="empty-log">Waiting for Claudeâ€¦</span></div>
</div>

<!-- Corpus Library -->
<div class="card">
  <h2>Corpus Library</h2>
  <ul class="doc-list" id="docList">
    <li style="padding:1rem; color:#aaa; text-align:center">Loadingâ€¦</li>
  </ul>
</div>

</div><!-- /col-tools -->

<!-- MIDDLE: Review Annotations -->
<div class="col-review">
<div class="card review-card">
  <div class="review-card-top">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.3rem">
      <h2 style="margin:0">Review Annotations</h2>
      <div style="display:flex; align-items:center; gap:0.8rem">
        <input type="text" id="reviewTagFilter" placeholder="Filter by tagâ€¦" style="width:120px; font-size:0.85rem" oninput="filterReviewCards()">
        <button class="btn-sm" onclick="loadReviewQueue()">â†» Refresh</button>
      </div>
    </div>
    <p style="color:#666; font-size:0.85rem; margin:0.4rem 0 0.5rem">Accept, reject, or correct LLM annotations. Click <strong>View</strong> to read the full source text.</p>
    <div id="reviewCounter" style="font-size:0.82rem; color:#888; margin-bottom:0.8rem"></div>
  </div>
  <div id="reviewQueue"><span style="color:#aaa; font-size:0.9rem">Loadingâ€¦</span></div>
</div>
</div><!-- /col-review -->

<!-- RIGHT: Source Document Viewer -->
<div class="col-viewer">
<div class="card viewer-card">
  <div class="viewer-card-top">
    <h2 style="margin-bottom:0.8rem">Source Document</h2>
  </div>
  <div id="viewerContent">
    <p class="viewer-placeholder">Click <strong>View</strong> on an annotation to read the full source text here.</p>
  </div>
</div>
</div><!-- /col-viewer -->

</div><!-- /workspace -->

<datalist id="ollamaModels">
  <!-- Ollama / local -->
  <option value="qwen2.5:7b">
  <option value="qwen2.5:14b">
  <option value="qwen2.5:32b">
  <option value="llama3.1:8b">
  <option value="llama3.2:3b">
  <option value="llama3.3:70b">
  <option value="mistral:7b">
  <option value="gemma3:4b">
  <option value="gemma3:12b">
  <option value="phi4:14b">
  <!-- OpenAI -->
  <option value="gpt-4o">
  <option value="gpt-4o-mini">
  <option value="o3-mini">
  <option value="o1">
  <!-- Anthropic -->
  <option value="claude-opus-4-6">
  <option value="claude-sonnet-4-6">
  <option value="claude-haiku-4-5-20251001">
  <!-- Google -->
  <option value="gemini-2.0-flash">
  <option value="gemini-1.5-pro">
</datalist>

<script>
// â”€â”€ File selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const dropZone   = document.getElementById('dropZone');
const fileInput  = document.getElementById('fileInput');
const fileNameEl = document.getElementById('fileName');
let selectedFiles = [];

function isAllowed(name) {
  return name.endsWith('.md') || name.endsWith('.txt');
}

// Read all text files from a FileSystemEntry recursively
async function readFilesFromEntry(entry, out = []) {
  if (entry.isFile) {
    if (isAllowed(entry.name)) {
      await new Promise((res, rej) => entry.file(f => { out.push(f); res(); }, rej));
    }
  } else if (entry.isDirectory) {
    const reader = entry.createReader();
    // readEntries returns up to 100 entries at a time; call repeatedly until done
    let batch;
    do {
      batch = await new Promise((res, rej) => reader.readEntries(res, rej));
      for (const e of batch) await readFilesFromEntry(e, out);
    } while (batch.length > 0);
  }
  return out;
}

dropZone.addEventListener('click', () => fileInput.click());

dropZone.addEventListener('dragover', e => {
  e.preventDefault();
  dropZone.classList.add('dragover');
});
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));

dropZone.addEventListener('drop', async e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  const items = [...(e.dataTransfer?.items ?? [])];
  const files = [];
  for (const item of items) {
    const entry = item.webkitGetAsEntry?.();
    if (entry) await readFilesFromEntry(entry, files);
  }
  if (files.length) {
    selectedFiles = files;
    updateFileName();
  }
});

fileInput.addEventListener('change', () => {
  selectedFiles = [...fileInput.files].filter(f => isAllowed(f.name));
  updateFileName();
});

function updateFileName() {
  if (!selectedFiles.length) { fileNameEl.textContent = ''; return; }
  fileNameEl.textContent = selectedFiles.length === 1
    ? selectedFiles[0].name
    : `${selectedFiles.length} files selected`;
}

// â”€â”€ Upload â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

document.getElementById('uploadForm').addEventListener('submit', async e => {
  e.preventDefault();
  const btn    = document.getElementById('submitBtn');
  const status = document.getElementById('uploadStatus');

  const filesToUpload = selectedFiles.length
    ? selectedFiles
    : [...(fileInput.files ?? [])].filter(f => isAllowed(f.name));

  if (!filesToUpload.length) {
    status.innerHTML = '<span class="error">âœ— No .md or .txt files selected.</span>';
    return;
  }

  btn.disabled = true;
  btn.textContent = 'Uploadingâ€¦';
  status.textContent = '';

  const form = new FormData(document.getElementById('uploadForm'));
  // Replace files field with our filtered set
  form.delete('files');
  for (const f of filesToUpload) form.append('files', f);

  // Parse tags as JSON array
  const tags = form.get('tags');
  if (tags) form.set('tags', JSON.stringify(String(tags).split(',').map(t => t.trim()).filter(Boolean)));

  try {
    const res  = await fetch('/api/upload', { method: 'POST', body: form });
    const data = await res.json();
    if (res.ok) {
      const count = Array.isArray(data) ? data.length : 1;
      status.innerHTML = `<span class="success">âœ“ ${count} document${count > 1 ? 's' : ''} uploaded.</span>`;
      document.getElementById('uploadForm').reset();
      fileNameEl.textContent = '';
      selectedFiles = [];
      loadDocuments();
    } else {
      throw new Error(data.error || 'Upload failed');
    }
  } catch (err) {
    status.innerHTML = `<span class="error">âœ— ${err.message}</span>`;
  } finally {
    btn.disabled = false;
    btn.textContent = 'Upload Documents';
  }
});

// â”€â”€ Search â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function escapeHtml(str) {
  return String(str)
    .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;');
}

function renderSnippet(raw) {
  // Convert **match** markers from FTS5 snippet() into <mark> tags
  return escapeHtml(raw).replace(/\*\*(.+?)\*\*/g, '<mark>$1</mark>');
}

async function doSearch() {
  const q = document.getElementById('searchInput').value.trim();
  const container = document.getElementById('searchResults');
  if (!q) { container.innerHTML = ''; return; }

  container.innerHTML = '<p style="color:#aaa; font-size:0.9rem">Searchingâ€¦</p>';
  try {
    const res  = await fetch('/api/search?q=' + encodeURIComponent(q));
    const rows = await res.json();
    if (!rows.length) {
      container.innerHTML = '<p style="color:#aaa; font-size:0.9rem">No results found.</p>';
      return;
    }
    container.innerHTML = rows.map(row => {
      const tags = JSON.parse(row.tags || '[]').map(t => `<span class="badge">${escapeHtml(t)}</span>`).join('');
      return `
        <div class="search-result">
          <strong>${escapeHtml(row.title)}</strong>
          <div class="meta">${escapeHtml(row.author || 'Unknown')} Â· ${escapeHtml(row.publication_date || '')} ${tags}</div>
          <div class="snippet">${renderSnippet(row.snippet || '')}</div>
        </div>`;
    }).join('');
  } catch (err) {
    container.innerHTML = `<p class="error">Search failed: ${err.message}</p>`;
  }
}

document.getElementById('searchBtn').addEventListener('click', doSearch);
document.getElementById('searchInput').addEventListener('keydown', e => {
  if (e.key === 'Enter') doSearch();
});

// â”€â”€ Corpus library â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function loadDocuments() {
  const list = document.getElementById('docList');
  try {
    const res  = await fetch('/api/documents');
    const docs = await res.json();
    if (!docs.length) {
      list.innerHTML = '<li style="padding:1rem; color:#aaa; text-align:center">No documents yet. Upload some above!</li>';
      return;
    }
    list.innerHTML = docs.map(doc => {
      const tags = JSON.parse(doc.tags || '[]').map(t => `<span class="badge">${escapeHtml(t)}</span>`).join('');
      const meta = JSON.parse(doc.metadata || '{}');
      const size = ((meta.size || 0) / 1024).toFixed(1);
      return `
        <li class="doc-item" style="flex-direction:column; align-items:stretch">
          <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:1rem">
            <div style="min-width:0; flex:1">
              <strong style="cursor:pointer; color:#3f51b5" onclick="toggleAnnotations('${doc.id}', this)">
                ${escapeHtml(doc.title)}
              </strong>
              <div class="doc-meta">${escapeHtml(doc.author || 'â€”')} Â· ${escapeHtml(doc.publication_date || 'Unknown date')} Â· ${size} KB</div>
              <div style="margin-top:0.3rem">${tags}</div>
            </div>
            <div style="flex-shrink:0; text-align:right">
              <button class="danger" style="padding:0.3rem 0.7rem; font-size:0.8rem" onclick="deleteDoc('${doc.id}')">Delete</button>
              <div class="doc-id">${doc.id}</div>
            </div>
          </div>
          <div class="annotation-panel" id="ann-${doc.id}">
            <div class="annotation-list" id="ann-list-${doc.id}">
              <p style="color:#aaa; font-size:0.85rem; padding:0.3rem 0">Loading annotationsâ€¦</p>
            </div>
            <div class="add-ann-form">
              <strong style="font-size:0.85rem; color:#555">Add your annotation</strong>
              <textarea id="ann-text-${doc.id}" placeholder="Your interpretation, correction, or additional contextâ€¦"></textarea>
              <div class="add-ann-row">
                <input type="text" id="ann-tag-${doc.id}" placeholder="tag (e.g. kantian-sublime)">
                <input type="text" id="ann-corrects-${doc.id}" placeholder="corrects annotation ID (optional)">
                <button class="btn-sm" onclick="submitAnnotation('${doc.id}')">Add</button>
              </div>
            </div>
          </div>
        </li>`;
    }).join('');
  } catch (err) {
    list.innerHTML = `<li class="error" style="padding:1rem">Failed to load: ${err.message}</li>`;
  }
}

async function toggleAnnotations(docId, titleEl) {
  const panel = document.getElementById('ann-' + docId);
  const isOpen = panel.classList.toggle('open');
  titleEl.textContent = (isOpen ? 'â–¾ ' : '') + titleEl.textContent.replace(/^â–¾ /, '');
  if (isOpen) await loadAnnotations(docId);
}

async function loadAnnotations(docId) {
  const listEl = document.getElementById('ann-list-' + docId);
  try {
    const res   = await fetch('/api/documents/' + docId + '/annotations');
    const anns  = await res.json();
    if (!anns.length) {
      listEl.innerHTML = '<p style="color:#aaa; font-size:0.85rem; padding:0.3rem 0">No annotations yet.</p>';
      return;
    }
    listEl.innerHTML = '<ul class="annotation-list">' + anns.map(a => {
      const cls     = a.author_type === 'human' ? 'human' : 'llm';
      const label   = a.author_type === 'human' ? 'ğŸ‘¤ Human' : `ğŸ¤– LLM${a.author_id ? ' Â· ' + escapeHtml(a.author_id) : ''}`;
      const tagHtml = a.tag ? `<span class="ann-tag">${escapeHtml(a.tag)}</span>` : '';
      const correctsHtml = a.corrects_id ? `<span class="ann-corrects">â†³ corrects ${escapeHtml(a.corrects_id.slice(0, 8))}â€¦</span>` : '';
      const deleteBtn = a.author_type === 'human'
        ? `<button class="ann-delete" title="Delete" onclick="deleteAnnotation('${a.id}', '${docId}')">âœ•</button>`
        : '';
      const time = new Date(a.updated_at).toLocaleDateString();
      return `<li class="ann-item ${cls}">
        ${deleteBtn}
        ${escapeHtml(a.text)}
        <div class="ann-meta">${label} Â· ${time} ${tagHtml} ${correctsHtml}</div>
      </li>`;
    }).join('') + '</ul>';
  } catch (err) {
    listEl.innerHTML = `<p class="error" style="font-size:0.85rem">Failed to load: ${err.message}</p>`;
  }
}

async function submitAnnotation(docId) {
  const text     = document.getElementById('ann-text-' + docId).value.trim();
  const tag      = document.getElementById('ann-tag-' + docId).value.trim();
  const corrects = document.getElementById('ann-corrects-' + docId).value.trim();
  if (!text) return;
  try {
    const res = await fetch('/api/documents/' + docId + '/annotations', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text, tag: tag || undefined, corrects_id: corrects || undefined }),
    });
    if (!res.ok) throw new Error((await res.json()).error);
    document.getElementById('ann-text-' + docId).value = '';
    document.getElementById('ann-tag-' + docId).value = '';
    document.getElementById('ann-corrects-' + docId).value = '';
    await loadAnnotations(docId);
    loadDocuments();  // refresh badge counts
  } catch (err) {
    alert('Failed to add annotation: ' + err.message);
  }
}

async function deleteAnnotation(annId, docId) {
  if (!confirm('Delete this annotation?')) return;
  await fetch('/api/annotations/' + annId, { method: 'DELETE' });
  await loadAnnotations(docId);
}

async function deleteDoc(id) {
  if (!confirm('Delete this document and all its annotations from the corpus?')) return;
  await fetch(`/api/documents/${id}`, { method: 'DELETE' });
  loadDocuments();
}

// â”€â”€ Activity log â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const toolColors = {
  search_corpus:     'search',
  search_logs:       'search',
  analyze_document:  'analyze',
  annotate_document: 'annotate',
  remember_fact:     'memory',
  recall_fact:       'memory',
};

const toolIcons = {
  search_corpus:     'ğŸ”',
  search_logs:       'ğŸ”',
  analyze_document:  'ğŸ”¬',
  annotate_document: 'âœï¸',
  remember_fact:     'ğŸ§ ',
  recall_fact:       'ğŸ§ ',
  read_corpus:       'ğŸ“š',
  get_document:      'ğŸ“„',
  log_entry:         'ğŸ“',
  sync_now:          'ğŸ”„',
};

function renderActivity(entries) {
  const container = document.getElementById('activityLog');
  if (!entries.length) {
    container.innerHTML = '<span class="empty-log">No activity yet. Ask Claude to search or analyze the corpus.</span>';
    return;
  }
  container.innerHTML = entries.map(entry => {
    const time  = new Date(entry.timestamp).toLocaleTimeString();
    const cls   = toolColors[entry.tool] || 'default';
    const icon  = toolIcons[entry.tool] || 'âš™ï¸';
    const params = JSON.parse(entry.params || '{}');
    const paramStr = Object.entries(params)
      .map(([k, v]) => `${k}=${JSON.stringify(v)}`)
      .join(' ')
      .slice(0, 120);
    const sqlBlock = entry.sql_preview
      ? `<div class="log-sql">${escapeHtml(entry.sql_preview)}</div>`
      : '';
    return `
      <div class="log-entry">
        <span class="log-time">[${time}]</span>
        <span class="log-tool ${cls}"> ${icon} ${entry.tool}</span>
        <span style="color:#546e7a"> ${escapeHtml(paramStr)}</span>
        ${entry.result_summary ? `<div class="log-summary">â†’ ${escapeHtml(entry.result_summary)}</div>` : ''}
        ${sqlBlock}
      </div>`;
  }).join('');
}

let lastActivityCount = 0;
async function pollActivity() {
  try {
    const res     = await fetch('/api/activity');
    const entries = await res.json();
    if (entries.length !== lastActivityCount) {
      lastActivityCount = entries.length;
      renderActivity(entries);
    }
  } catch {
    // Ignore poll errors silently
  }
}

setInterval(pollActivity, 2000);
pollActivity();

// â”€â”€ Ask the AI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const toolIcons2 = {
  search_corpus:     'ğŸ”', analyze_document: 'ğŸ”¬',
  annotate_document: 'âœï¸', list_annotations: 'ğŸ“‹',
  get_document:      'ğŸ“„', read_corpus:      'ğŸ“š',
};

async function runQuery() {
  const systemPrompt = document.getElementById('systemPrompt').value.trim();
  const userMessage  = document.getElementById('userMessage').value.trim();
  const model        = document.getElementById('modelName').value.trim() || 'qwen2.5:7b';
  const ollamaUrl    = document.getElementById('runEndpoint').value.trim() || 'http://localhost:11434/v1/chat/completions';
  const apiKey       = document.getElementById('runApiKey').value.trim() || null;
  const btn          = document.getElementById('runBtn');
  const status       = document.getElementById('runStatus');
  const output       = document.getElementById('runOutput');

  if (!userMessage) { alert('Please enter a question.'); return; }

  btn.disabled  = true;
  btn.textContent = 'â³ Runningâ€¦';
  status.textContent = '';
  output.style.display = 'block';
  output.innerHTML = '<span class="empty-log">Connecting to modelâ€¦</span>';

  let html = '';
  const append = (block) => { html += block; output.innerHTML = html; output.scrollTop = output.scrollHeight; };

  try {
    const res = await fetch('/api/run', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ systemPrompt, userMessage, model, ollamaUrl, apiKey }),
    });

    if (!res.ok) {
      const err = await res.json();
      output.innerHTML = `<span class="error">âœ— ${escapeHtml(err.error || 'Request failed')}</span>`;
      return;
    }

    output.innerHTML = '';
    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let buf = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buf += decoder.decode(value, { stream: true });
      const lines = buf.split('\n');
      buf = lines.pop();

      for (const line of lines) {
        if (!line.startsWith('data: ')) continue;
        let evt;
        try { evt = JSON.parse(line.slice(6)); } catch { continue; }

        if (evt.type === 'tool_call') {
          const icon = toolIcons2[evt.name] || 'âš™ï¸';
          const argsStr = escapeHtml(JSON.stringify(evt.args).slice(0, 120));
          append(`<div class="log-entry"><span class="log-tool annotate">${icon} ${escapeHtml(evt.name)}</span> <span style="color:#546e7a">${argsStr}</span></div>`);

        } else if (evt.type === 'tool_result') {
          append(`<div class="log-entry" style="margin-top:-0.6rem; padding-top:0"><div class="log-summary">â†³ ${escapeHtml(evt.result.slice(0, 300))}${evt.result.length > 300 ? 'â€¦' : ''}</div></div>`);

        } else if (evt.type === 'answer') {
          append(`<div class="log-entry" style="border-top:1px solid #2d2d4e; padding-top:0.8rem; margin-top:0.4rem"><span class="log-tool memory">âœ“ Answer</span><div style="color:#e0e0e0; margin-top:0.4rem; white-space:pre-wrap">${escapeHtml(evt.text)}</div></div>`);
          status.innerHTML = '<span class="success">Done.</span>';
          loadDocuments(); // refresh annotation counts

        } else if (evt.type === 'error') {
          append(`<div class="log-entry"><span class="error">âœ— ${escapeHtml(evt.message)}</span></div>`);
          status.innerHTML = '<span class="error">Error.</span>';
        }
      }
    }
  } catch (err) {
    output.innerHTML = `<span class="error">âœ— ${escapeHtml(err.message)}</span>`;
    status.innerHTML = '<span class="error">Error.</span>';
  } finally {
    btn.disabled = false;
    btn.textContent = 'â–¶ Run';
  }
}

// â”€â”€ Model presets (shared by Ask the Corpus and Batch Annotate) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setPreset(card, preset) {
  const ids = card === 'run'
    ? { model: 'modelName',  endpoint: 'runEndpoint',   apiKey: 'runApiKey'   }
    : { model: 'batchModel', endpoint: 'batchEndpoint', apiKey: 'batchApiKey' };
  const model    = document.getElementById(ids.model);
  const endpoint = document.getElementById(ids.endpoint);
  const apiKey   = document.getElementById(ids.apiKey);
  if (preset === 'ollama') {
    model.value        = 'qwen2.5:7b';
    endpoint.value     = 'http://localhost:11434/v1/chat/completions';
    apiKey.value       = '';
    apiKey.placeholder = 'sk-â€¦ (leave blank for Ollama)';
  } else if (preset === 'claude') {
    model.value        = 'claude-haiku-4-5-20251001';
    endpoint.value     = 'https://api.anthropic.com/v1/messages';
    apiKey.value       = '';
    apiKey.placeholder = 'sk-ant-â€¦';
  } else if (preset === 'openai') {
    model.value        = 'gpt-4o-mini';
    endpoint.value     = 'https://api.openai.com/v1/chat/completions';
    apiKey.value       = '';
    apiKey.placeholder = 'sk-â€¦';
  }
}

// â”€â”€ Batch Annotate â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

document.getElementById('batchDelay').addEventListener('input', function () {
  document.getElementById('batchDelayLabel').textContent = this.value + ' ms';
});

let batchReader = null;

function batchStop() {
  if (batchReader) { batchReader.cancel(); batchReader = null; }
}

async function batchRun() {
  const concept    = document.getElementById('batchConcept').value.trim();
  const tag        = document.getElementById('batchTag').value.trim();
  const model      = document.getElementById('batchModel').value.trim() || 'qwen2.5:7b';
  const ollamaUrl  = document.getElementById('batchEndpoint').value.trim() || 'http://localhost:11434/v1/chat/completions';
  const apiKey     = document.getElementById('batchApiKey').value.trim() || null;
  const resume     = document.getElementById('batchResume').checked;
  const delayMs    = Number(document.getElementById('batchDelay').value);

  if (!concept) { alert('Please enter a concept.'); return; }
  if (!tag)     { alert('Please enter a tag.'); return; }

  const runBtn    = document.getElementById('batchRunBtn');
  const stopBtn   = document.getElementById('batchStopBtn');
  const statusEl  = document.getElementById('batchStatus');
  const progress  = document.getElementById('batchProgressArea');
  const bar       = document.getElementById('batchProgressBar');
  const docTitle  = document.getElementById('batchDocTitle');
  const cntAnn    = document.getElementById('batchAnnotated');
  const cntSkip   = document.getElementById('batchSkipped');
  const cntErr    = document.getElementById('batchErrors');
  const output    = document.getElementById('batchOutput');

  runBtn.disabled = true;
  stopBtn.style.display = '';
  statusEl.textContent = 'Startingâ€¦';
  progress.classList.add('active');
  output.style.display = 'block';
  output.innerHTML = '';

  let html = '';
  let annCount = 0, skipCount = 0, errCount = 0, total = 0;

  const append = (block) => { html += block; output.innerHTML = html; output.scrollTop = output.scrollHeight; };

  try {
    const res = await fetch('/api/batch-run', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ concept, tag, model, ollamaUrl, apiKey, resume, delayMs }),
    });

    if (!res.ok) {
      let errMsg = `HTTP ${res.status}`;
      try { const err = await res.json(); errMsg = err.error || errMsg; } catch {}
      statusEl.innerHTML = `<span class="error">âœ— ${escapeHtml(errMsg)}</span>`;
      return;
    }

    batchReader = res.body.getReader();
    const decoder = new TextDecoder();
    let buf = '';

    while (true) {
      const { done, value } = await batchReader.read();
      if (done) break;
      buf += decoder.decode(value, { stream: true });
      const lines = buf.split('\n');
      buf = lines.pop();

      for (const line of lines) {
        if (!line.startsWith('data: ')) continue;
        let evt;
        try { evt = JSON.parse(line.slice(6)); } catch { continue; }

        if (evt.type === 'started') {
          total = evt.total;
          bar.max = total || 1;
          bar.value = 0;
          statusEl.textContent = `0 / ${total} documents`;
          append(`<div class="log-entry"><span class="log-tool memory">â–¶ Batch started â€” ${total} document${total !== 1 ? 's' : ''}</span></div>`);

        } else if (evt.type === 'progress') {
          bar.value = evt.current;
          statusEl.textContent = `Processing ${evt.current} / ${evt.total}â€¦`;
          docTitle.textContent = evt.title;
          append(`<div class="log-entry"><span class="log-tool default">â–¸ [${evt.current}/${evt.total}] ${escapeHtml(evt.title)}</span></div>`);

        } else if (evt.type === 'skipped') {
          bar.value = evt.current;
          skipCount++;
          cntSkip.textContent = `âŸ² ${skipCount} skipped`;
          append(`<div class="log-entry" style="opacity:0.45"><span style="color:#90caf9">âŸ² skip</span> ${escapeHtml(evt.title)}</div>`);

        } else if (evt.type === 'tool_call') {
          const icon = toolIcons2[evt.name] || 'âš™ï¸';
          const argsStr = escapeHtml(JSON.stringify(evt.args).slice(0, 120));
          append(`<div class="log-entry"><span class="log-tool annotate">${icon} ${escapeHtml(evt.name)}</span> <span style="color:#546e7a">${argsStr}</span></div>`);

        } else if (evt.type === 'tool_result') {
          if (evt.name === 'annotate_document') annCount++, cntAnn.textContent = `âœ“ ${annCount} annotated`;
          append(`<div class="log-entry" style="margin-top:-0.6rem; padding-top:0"><div class="log-summary">â†³ ${escapeHtml(evt.result.slice(0, 300))}${evt.result.length > 300 ? 'â€¦' : ''}</div></div>`);

        } else if (evt.type === 'error') {
          errCount++;
          cntErr.textContent = `âœ— ${errCount} errors`;
          append(`<div class="log-entry"><span class="error">âœ— ${escapeHtml(evt.message)}</span></div>`);

        } else if (evt.type === 'done') {
          bar.value = evt.total;
          statusEl.textContent = `Done â€” ${evt.annotated} annotated, ${evt.skipped} skipped, ${evt.errors} errors`;
          append(`<div class="log-entry" style="border-top:1px solid #2d2d4e; padding-top:0.8rem; margin-top:0.4rem"><span class="log-tool memory">âœ“ Batch complete</span><div class="log-summary">annotated: ${evt.annotated} Â· skipped: ${evt.skipped} Â· errors: ${evt.errors} Â· total: ${evt.total}</div></div>`);
          loadDocuments();
        }
      }
    }
  } catch (err) {
    if (err.name !== 'AbortError') {
      statusEl.innerHTML = `<span class="error">âœ— ${escapeHtml(err.message)}</span>`;
    }
  } finally {
    batchReader = null;
    runBtn.disabled = false;
    stopBtn.style.display = 'none';
  }
}

// â”€â”€ Review Mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let reviewPendingCount = 0;
const reviewAnnMap = {}; // annId â†’ { document_id, text }

async function loadReviewQueue() {
  const tag    = document.getElementById('reviewTagFilter').value.trim();
  const url    = '/api/annotations/review' + (tag ? '?tag=' + encodeURIComponent(tag) : '');
  const queueEl = document.getElementById('reviewQueue');
  queueEl.innerHTML = '<span style="color:#aaa; font-size:0.9rem">Loadingâ€¦</span>';
  try {
    const data = await fetch(url).then(r => r.json());
    renderReviewQueue(data.annotations || [], data.counts || []);
  } catch (e) {
    queueEl.innerHTML = '<span class="error">Failed to load review queue.</span>';
  }
}

function renderReviewQueue(items, counts) {
  const queueEl   = document.getElementById('reviewQueue');
  const counterEl = document.getElementById('reviewCounter');

  // Store for safe lookup by viewDocument (avoids HTML-encoding issues in onclick)
  for (const ann of items) reviewAnnMap[ann.id] = { document_id: ann.document_id, text: ann.text };

  const pending  = (counts.find(c => c.review_status === 'pending')  || {}).n || 0;
  const accepted = (counts.find(c => c.review_status === 'accepted') || {}).n || 0;
  const rejected = (counts.find(c => c.review_status === 'rejected') || {}).n || 0;
  reviewPendingCount = pending;

  const total = pending + accepted + rejected;
  counterEl.innerHTML = total > 0
    ? `<span id="reviewPendingSpan" style="color:#5c6bc0; font-weight:600">${pending}</span> pending Â· <span style="color:#388e3c">${accepted}</span> accepted Â· <span style="color:#c62828">${rejected}</span> rejected`
    : '<span id="reviewPendingSpan" style="color:#aaa">0</span> pending';

  if (!items.length) {
    queueEl.innerHTML = '<p style="color:#aaa; text-align:center; padding:1rem 0">No pending annotations. Run Batch Annotate to generate some, then return here to review them.</p>';
    return;
  }

  queueEl.innerHTML = items.map(ann => `
    <div class="review-item" id="rev-${ann.id}" data-tag="${escapeHtml(ann.tag || '')}">
      <div class="review-item-header">
        ${ann.tag ? `<span class="badge">${escapeHtml(ann.tag)}</span>` : ''}
        <span class="review-doc-title" title="${escapeHtml(ann.document_title)}">${escapeHtml(ann.document_title)}</span>
        <span class="ann-meta">${escapeHtml(ann.author_id || 'llm')} Â· ${new Date(ann.updated_at).toLocaleDateString()}</span>
      </div>
      <div class="review-item-text">${escapeHtml(ann.text)}</div>
      <div class="review-actions" id="rev-actions-${ann.id}">
        <button class="btn-sm btn-accept" onclick="acceptAnnotation('${ann.id}')">âœ“ Accept</button>
        <button class="btn-sm btn-edit-open" onclick="startReviewEdit('${ann.id}')">âœ Edit</button>
        <button class="btn-sm danger" onclick="rejectAnnotation('${ann.id}')">âœ— Reject</button>
        <button class="btn-sm" style="background:#e8eaf6; color:#3f51b5" onclick="viewFromAnnotation('${ann.id}')">âŠ View</button>
      </div>
      <div id="rev-edit-${ann.id}" style="display:none; margin-top:0.6rem">
        <textarea class="edit-textarea" id="rev-text-${ann.id}">${escapeHtml(ann.text)}</textarea>
        <input type="text" id="rev-tag-${ann.id}" value="${escapeHtml(ann.tag || '')}" placeholder="Tag" style="margin-top:0.4rem; font-size:0.85rem; width:100%">
        <div style="display:flex; gap:0.5rem; margin-top:0.5rem">
          <button class="btn-sm" onclick="saveReviewEdit('${ann.id}')">Save correction</button>
          <button class="btn-sm" style="background:#b0bec5; color:#333" onclick="cancelReviewEdit('${ann.id}')">Cancel</button>
        </div>
      </div>
    </div>
  `).join('');
}

function filterReviewCards() {
  const filter = document.getElementById('reviewTagFilter').value.toLowerCase();
  document.querySelectorAll('.review-item').forEach(el => {
    el.style.display = (!filter || el.dataset.tag.toLowerCase().includes(filter)) ? '' : 'none';
  });
}

async function acceptAnnotation(id) { await reviewAction(id, 'accept'); }
async function rejectAnnotation(id) { await reviewAction(id, 'reject'); }

function startReviewEdit(id) {
  document.getElementById('rev-actions-' + id).style.display = 'none';
  document.getElementById('rev-edit-' + id).style.display = 'block';
  document.getElementById('rev-text-' + id).focus();
}

function cancelReviewEdit(id) {
  document.getElementById('rev-edit-' + id).style.display = 'none';
  document.getElementById('rev-actions-' + id).style.display = 'flex';
}

async function saveReviewEdit(id) {
  const correction = document.getElementById('rev-text-' + id).value.trim();
  const tag        = document.getElementById('rev-tag-' + id).value.trim();
  if (!correction) { alert('Correction text cannot be empty.'); return; }
  await reviewAction(id, 'edit', correction, tag);
}

async function reviewAction(id, action, correction, tag) {
  try {
    const body = { action };
    if (correction !== undefined) body.correction = correction;
    if (tag        !== undefined) body.tag        = tag;

    const r = await fetch('/api/annotations/' + id + '/review', {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });
    if (!r.ok) throw new Error((await r.json()).error);

    // Fade card out and remove
    const card = document.getElementById('rev-' + id);
    if (card) {
      card.style.opacity = '0';
      setTimeout(() => {
        card.remove();
        reviewPendingCount = Math.max(0, reviewPendingCount - 1);
        const span = document.getElementById('reviewPendingSpan');
        if (span) span.textContent = reviewPendingCount;
        if (document.querySelectorAll('.review-item').length === 0) {
          document.getElementById('reviewQueue').innerHTML =
            '<p style="color:#388e3c; text-align:center; padding:1rem 0">âœ“ All done â€” no pending annotations.</p>';
        }
      }, 160);
    }

    if (action === 'edit') loadDocuments(); // refresh doc annotation counts
  } catch (e) {
    alert('Error: ' + e.message);
  }
}

// â”€â”€ Supabase sync â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function pollSyncStatus() {
  try {
    const r   = await fetch('/api/sync/status');
    const s   = await r.json();
    const el  = document.getElementById('syncStatusBadge');
    const btn = document.getElementById('syncBtn');

    if (!s.configured) {
      el.textContent   = 'Supabase not configured';
      el.style.color   = '#aaa';
      btn.disabled     = true;
      btn.title        = 'Add SUPABASE_URL and SUPABASE_KEY to .env to enable sync';
      return;
    }

    const dirty = (s.dirty_documents || 0) + (s.dirty_annotations || 0);
    btn.disabled = false;
    if (dirty > 0) {
      el.textContent = `${dirty} unsynced`;
      el.style.color = '#e65100';
    } else {
      const lastRaw = s.last_synced_documents || s.last_synced_annotations;
      el.textContent = lastRaw ? `Synced ${new Date(lastRaw).toLocaleTimeString()}` : 'Not synced yet';
      el.style.color = '#2e7d32';
    }
  } catch { /* ignore poll errors */ }
}

async function triggerSync() {
  const btn = document.getElementById('syncBtn');
  const el  = document.getElementById('syncStatusBadge');
  btn.disabled    = true;
  btn.textContent = 'â†‘â†“ Syncingâ€¦';
  el.textContent  = 'Syncingâ€¦';
  el.style.color  = '#5c6bc0';
  try {
    const r    = await fetch('/api/sync', { method: 'POST' });
    const data = await r.json();
    if (!r.ok) throw new Error(data.error);
    await pollSyncStatus();
    loadDocuments(); // annotations may have arrived from Supabase
  } catch (err) {
    el.textContent = 'âœ— Sync failed';
    el.style.color = '#c62828';
    alert('Sync failed: ' + err.message);
  } finally {
    btn.disabled    = false;
    btn.textContent = 'â†‘â†“ Sync';
  }
}

// Poll sync status every 10 s so the dirty count stays current
setInterval(pollSyncStatus, 10000);

// â”€â”€ Delete all â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

document.getElementById('deleteAllBtn').addEventListener('click', async () => {
  const res = await fetch('/api/documents');
  const docs = await res.json();
  const count = docs.length;
  if (!count) { alert('Corpus is already empty.'); return; }
  if (!confirm(`Delete all ${count} document${count > 1 ? 's' : ''} and their annotations? This cannot be undone.`)) return;
  try {
    const r = await fetch('/api/corpus', { method: 'DELETE' });
    const data = await r.json();
    if (!r.ok) throw new Error(data.error);
    loadDocuments();
  } catch (err) {
    alert('Delete failed: ' + err.message);
  }
});

// â”€â”€ Developer options toggle arrow â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.querySelector('details').addEventListener('toggle', function () {
  this.querySelector('summary span').textContent = this.open ? 'â–¾' : 'â–¸';
});

// â”€â”€ Document viewer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function viewFromAnnotation(annId) {
  const ann = reviewAnnMap[annId];
  if (ann) viewDocument(ann.document_id, ann.text);
}

async function viewDocument(docId, annotationText) {
  const panel = document.getElementById('viewerContent');
  panel.innerHTML = '<span style="color:#aaa; font-size:0.9rem">Loadingâ€¦</span>';

  try {
    const doc = await fetch('/api/documents/' + docId).then(r => r.json());

    const meta = [doc.author, doc.publication_date].filter(Boolean).join(' Â· ');
    const header = `<div class="viewer-doc-header">
      <strong style="font-size:0.95rem">${escapeHtml(doc.title || 'Untitled')}</strong>
      ${meta ? `<div style="font-size:0.82rem; color:#888; margin-top:0.2rem">${escapeHtml(meta)}</div>` : ''}
    </div>`;

    // Try to highlight the annotation passage verbatim
    let body = escapeHtml(doc.content || '');
    if (annotationText) {
      const needle = escapeHtml(annotationText);
      const idx = body.indexOf(needle);
      if (idx >= 0) {
        body = body.slice(0, idx)
          + '<mark>' + needle + '</mark>'
          + body.slice(idx + needle.length);
      }
    }

    panel.innerHTML = header + `<div class="viewer-body">${body}</div>`;

    const mark = panel.querySelector('mark');
    if (mark) mark.scrollIntoView({ behavior: 'smooth', block: 'center' });
  } catch (e) {
    panel.innerHTML = '<span class="error">Failed to load document.</span>';
  }
}

// â”€â”€ Boot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
loadDocuments();
loadReviewQueue();
pollSyncStatus();

// Populate model datalist from Ollama (best-effort, falls back to hardcoded options)
(async () => {
  try {
    const res = await fetch('http://localhost:11434/api/tags');
    if (!res.ok) return;
    const { models } = await res.json();
    if (!Array.isArray(models) || !models.length) return;
    const dl = document.getElementById('ollamaModels');
    dl.innerHTML = models
      .map(m => `<option value="${m.name}">`)
      .join('');
  } catch { /* Ollama not running â€” keep hardcoded fallbacks */ }
})();
</script>

</body>
</html>
