<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Keel · Corpus</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      margin: 0; padding: 0;
      background: #f0f2f5;
      color: #1a1a2e;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 2px solid #dde1ea;
      padding: 0.7rem 1.5rem;
      flex-shrink: 0;
      background: white;
    }
    h1 { margin: 0; font-size: 1.35rem; color: #1a1a2e; letter-spacing: -0.02em; }
    h1 span { color: #5c6bc0; }
    h2 { margin: 0 0 0.9rem; font-size: 0.95rem; font-weight: 700; color: #333;
         text-transform: uppercase; letter-spacing: 0.06em; }

    /* ── Three-column workspace ── */
    .workspace {
      display: grid;
      grid-template-columns: 255px 1fr 1fr;
      gap: 1rem;
      flex: 1;
      min-height: 0;
      padding: 1rem 1.5rem;
      overflow: hidden;
    }

    .col-sidebar {
      overflow-y: auto;
      min-height: 0;
    }

    .col-corpus, .col-viewer {
      overflow-y: hidden;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }

    /* ── Cards ── */
    .card {
      background: white;
      padding: 1.2rem 1.4rem;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.07);
      margin-bottom: 1rem;
    }

    /* ── Corpus card (fills center column) ── */
    .corpus-card {
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
      margin-bottom: 0;
    }
    .corpus-toolbar {
      display: flex;
      align-items: center;
      gap: 0.7rem;
      margin-bottom: 0.5rem;
      flex-shrink: 0;
    }
    .corpus-title-area { flex: 0 0 auto; }
    .doc-count { font-size: 0.8rem; color: #aaa; font-weight: 400;
                 text-transform: none; letter-spacing: 0; }

    /* ── Search row ── */
    .search-row {
      display: flex;
      gap: 0.4rem;
      flex: 1;
    }
    .search-row input { flex: 1; min-width: 0; }

    /* ── Filter indicator ── */
    .filter-bar {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: #eef0fb;
      border-radius: 6px;
      padding: 0.3rem 0.8rem;
      margin-bottom: 0.5rem;
      font-size: 0.83rem;
      color: #3f51b5;
      flex-shrink: 0;
    }
    .filter-bar .clear-btn {
      background: none; border: none; color: #9fa8da;
      cursor: pointer; padding: 0; font-size: 0.85rem;
      margin-left: auto; line-height: 1;
    }
    .filter-bar .clear-btn:hover { color: #c62828; background: none; }

    /* ── Scrollable doc list ── */
    .doc-list {
      list-style: none;
      padding: 0; margin: 0;
      flex: 1;
      overflow-y: auto;
      min-height: 0;
    }

    /* ── Document cards ── */
    .doc-card {
      padding: 0.75rem 2rem 0.75rem 0;
      border-bottom: 1px solid #f0f2f5;
      position: relative;
    }
    .doc-card:last-child { border-bottom: none; }

    .doc-main { cursor: pointer; margin-bottom: 0.4rem; }
    .doc-main:hover .doc-title { color: #3f51b5; }
    .doc-title {
      font-size: 0.9rem; font-weight: 500; color: #1a1a2e;
      line-height: 1.35;
    }
    .doc-meta { font-size: 0.77rem; color: #aaa; margin-top: 0.1rem; }

    .doc-snippet {
      font-size: 0.82rem; color: #555; line-height: 1.5; margin-top: 0.3rem;
    }
    .doc-snippet mark {
      background: #fff176; color: #1a1a2e; border-radius: 2px; padding: 0 1px;
    }

    /* ── Tags row ── */
    .doc-tags {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.3rem;
      margin-top: 0.35rem;
    }

    .tag-chip {
      display: inline-flex;
      align-items: center;
      background: #e8eaf6; color: #3f51b5;
      border-radius: 12px;
      padding: 0.08rem 0.4rem 0.08rem 0.55rem;
      font-size: 0.75rem; font-weight: 500;
      cursor: pointer; white-space: nowrap;
    }
    .tag-chip:hover { background: #c5cae9; }
    .tag-remove {
      background: none; border: none;
      color: #9fa8da; cursor: pointer;
      padding: 0 0 0 0.15rem;
      font-size: 0.9rem; line-height: 1;
      display: flex; align-items: center;
    }
    .tag-remove:hover { color: #c62828; background: none; }

    .btn-add-tag {
      background: none;
      border: 1px dashed #d1d5db;
      color: #bbb;
      border-radius: 12px;
      padding: 0.06rem 0.55rem;
      font-size: 0.74rem;
      cursor: pointer; line-height: 1.6;
    }
    .btn-add-tag:hover { border-color: #5c6bc0; color: #5c6bc0; background: none; }

    .tag-input-inline {
      border: 1px solid #5c6bc0;
      border-radius: 12px;
      padding: 0.06rem 0.6rem;
      font-size: 0.75rem;
      outline: none;
      width: 110px;
      font-family: inherit;
    }
    .tag-confirm-btn {
      background: #5c6bc0; color: white; border: none;
      border-radius: 10px; padding: 0.05rem 0.5rem;
      font-size: 0.73rem; cursor: pointer;
    }
    .tag-confirm-btn:hover { background: #3f51b5; }
    .tag-cancel-btn {
      background: none; border: none;
      color: #bbb; cursor: pointer; font-size: 0.85rem; line-height: 1;
    }
    .tag-cancel-btn:hover { color: #c62828; background: none; }

    /* ── Delete button (top-right of card) ── */
    .btn-doc-delete {
      position: absolute; top: 0.75rem; right: 0;
      background: none; border: none;
      color: #ddd; cursor: pointer;
      padding: 0.1rem 0.25rem; font-size: 0.9rem;
    }
    .btn-doc-delete:hover { color: #e53935; background: none; }

    /* ── Viewer card ── */
    .viewer-card {
      flex: 1; min-height: 0;
      display: flex; flex-direction: column;
      margin-bottom: 0;
    }
    #viewerContent {
      flex: 1; overflow-y: auto; min-height: 0;
    }
    .viewer-placeholder {
      color: #ccc; text-align: center;
      padding: 4rem 1.5rem; font-size: 0.88rem; line-height: 1.6;
    }
    .viewer-doc-header {
      border-bottom: 1px solid #eef0f5;
      padding-bottom: 0.8rem; margin-bottom: 1rem;
    }
    .viewer-body {
      white-space: pre-wrap; word-break: break-word;
      color: #333; font-size: 0.87rem; line-height: 1.8;
    }
    .viewer-body mark { background: #fff176; border-radius: 2px; padding: 0 2px; }

    /* ── Upload form ── */
    .upload-area {
      border: 2px dashed #c5cae9;
      padding: 1.5rem 1rem;
      text-align: center; border-radius: 8px;
      cursor: pointer; background: #fafbff;
      transition: border-color .2s, background .2s;
    }
    .upload-area:hover, .upload-area.dragover {
      border-color: #5c6bc0; background: #eef0fb;
    }
    .upload-area p { margin: 0.2rem 0; color: #666; font-size: 0.88rem; }
    .upload-area .hint { font-size: 0.78rem; color: #bbb; margin-top: 0.4rem; }
    #fileName { font-weight: 600; color: #5c6bc0; min-height: 1.1rem;
                margin-top: 0.4rem; font-size: 0.85rem; }

    .meta-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.7rem; margin: 0.7rem 0; }
    label { font-size: 0.8rem; color: #666; display: block; margin-bottom: 0.2rem; }

    input[type="text"], input[type="date"], input[type="search"] {
      width: 100%;
      padding: 0.48rem 0.65rem;
      border: 1px solid #dde1ea;
      border-radius: 6px;
      font-size: 0.88rem;
      background: #fafbff;
      font-family: inherit;
      color: #1a1a2e;
    }
    input:focus { outline: 2px solid #5c6bc0; border-color: transparent; }

    button {
      background: #5c6bc0; color: white; border: none;
      padding: 0.58rem 1.2rem; border-radius: 6px;
      cursor: pointer; font-size: 0.88rem; font-weight: 500;
      transition: background .15s; font-family: inherit;
    }
    button:hover { background: #3f51b5; }
    button:disabled { background: #b0bec5; cursor: not-allowed; }
    button.danger { background: #e53935; }
    button.danger:hover { background: #c62828; }
    .btn-sm { padding: 0.38rem 0.85rem; font-size: 0.82rem; }

    #uploadStatus { margin-top: 0.5rem; font-size: 0.85rem; font-weight: 500; }
    .success { color: #2e7d32; }
    .error { color: #c62828; }

    /* ── Collapsible upload card ── */
    details.card > summary {
      list-style: none; cursor: pointer;
      font-size: 0.88rem; font-weight: 700; color: #555;
      text-transform: uppercase; letter-spacing: 0.06em;
      user-select: none; display: flex; align-items: center; gap: 0.4rem;
    }
    details.card > summary::-webkit-details-marker { display: none; }
    details.card > summary .arrow { font-size: 0.68rem; color: #bbb; }
    details.card[open] > summary { margin-bottom: 0.9rem; }

    /* ── Tag browser (sidebar) ── */
    .tag-bar {
      display: flex; align-items: center; gap: 0.45rem;
      padding: 0.28rem 0.4rem; border-radius: 6px;
      cursor: pointer; margin-bottom: 0.18rem;
      transition: background .1s;
    }
    .tag-bar:hover { background: #f4f5f9; }
    .tag-bar.active { background: #eef0fb; }
    .tag-bar-label { font-size: 0.84rem; color: #444; white-space: nowrap; flex: 0 0 auto; }
    .tag-bar.active .tag-bar-label { color: #3f51b5; font-weight: 600; }
    .tag-bar-track { flex: 1; height: 4px; background: #eef0f5; border-radius: 3px;
                     overflow: hidden; min-width: 0; }
    .tag-bar-fill { height: 100%; background: #7986cb; border-radius: 3px; }
    .tag-bar-count { font-size: 0.72rem; color: #bbb; white-space: nowrap; flex: 0 0 auto; }

    /* ── Inline markup (==highlight== and #tag in viewer) ── */
    mark.inline-hl { background: #fff9c4; border-radius: 2px; padding: 0 2px; }

    /* ── Annotation highlights (DB-backed, coloured by tag) ── */
    .ann-hl {
      border-radius: 2px; padding: 0 1px;
      cursor: help; transition: filter 0.1s;
    }
    .ann-hl:hover { filter: brightness(0.88); }

    /* ── Floating annotation toolbar ── */
    #ann-toolbar {
      background: white;
      border: 1px solid #dde1ea;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.14);
      padding: 0.45rem 0.7rem;
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 0.45rem;
      font-family: system-ui, -apple-system, sans-serif;
    }
    .ann-toolbar-label { font-size: 0.76rem; color: #888; white-space: nowrap; }

    /* ── Annotation list (below document body) ── */
    .ann-list {
      margin-top: 1.8rem;
      border-top: 1px solid #eef0f5;
      padding-top: 1rem;
    }
    .ann-list-title {
      font-size: 0.74rem; font-weight: 700; color: #aaa;
      text-transform: uppercase; letter-spacing: 0.07em; margin-bottom: 0.6rem;
    }
    .ann-item {
      padding: 0.45rem 0.7rem;
      border-radius: 0 6px 6px 0;
      margin-bottom: 0.45rem;
      background: #fafbff;
    }
    .ann-item-tag {
      display: inline-block; border-radius: 10px;
      padding: 0.04rem 0.5rem; font-size: 0.73rem; font-weight: 600;
      color: #333; margin-bottom: 0.25rem;
    }
    .ann-item-passage {
      font-size: 0.82rem; color: #555; font-style: italic; line-height: 1.55;
    }
    .ann-item-note { font-size: 0.81rem; color: #333; margin-top: 0.2rem; line-height: 1.5; }
  </style>
</head>
<body>

<header>
  <h1>Keel <span>· Corpus</span></h1>
  <div style="display:flex; align-items:center; gap:0.8rem">
    <span id="syncStatusBadge" style="font-size:0.78rem; color:#aaa"></span>
    <button id="syncBtn" style="padding:0.38rem 0.85rem; font-size:0.8rem; display:none"
            onclick="triggerSync()">↑↓ Sync</button>
    <a href="/api/documents" target="_blank"
       style="font-size:0.8rem; color:#aaa; text-decoration:none">API ↗</a>
  </div>
</header>

<div class="workspace">

<!-- ── Left sidebar ── -->
<div class="col-sidebar">

  <!-- Upload (collapsed by default) -->
  <details class="card">
    <summary><span class="arrow">▸</span> Upload Documents</summary>
    <form id="uploadForm">
      <div class="upload-area" id="dropZone">
        <p>Drop a <strong>folder</strong> or click to select files</p>
        <p class="hint">.md and .txt files · drag a whole folder to import in bulk</p>
        <input type="file" id="fileInput" name="files" style="display:none"
               multiple accept=".md,.txt,text/plain,text/markdown">
        <div id="fileName"></div>
      </div>

      <div class="meta-grid">
        <div>
          <label>Author</label>
          <input type="text" name="author" placeholder="e.g. Eduard Hanslick">
        </div>
        <div>
          <label>Date</label>
          <input type="date" name="publication_date">
        </div>
      </div>

      <label>Tags <span style="color:#ccc; font-size:0.77rem">(comma-separated)</span></label>
      <input type="text" name="tags" placeholder="music, romanticism" style="margin-bottom:0.8rem">

      <button type="submit" id="submitBtn">Upload</button>
      <div id="uploadStatus"></div>
    </form>
  </details>

  <!-- Tag / category browser -->
  <div class="card">
    <h2>Browse by Tag</h2>
    <div id="tagList">
      <span style="color:#ccc; font-size:0.85rem">Loading…</span>
    </div>
  </div>

  <!-- Export -->
  <div style="padding: 0 0.2rem 0.5rem; text-align:center">
    <button id="exportBtn" class="btn-sm"
            style="font-size:0.76rem; opacity:0.7; width:100%; background:#f3f4f6; color:#555; border:1px solid #ddd">
      Export corpus (.zip)
    </button>
  </div>

  <!-- Danger zone -->
  <div style="padding: 0 0.2rem 0.5rem; text-align:center">
    <button id="deleteAllBtn" class="danger btn-sm"
            style="font-size:0.76rem; opacity:0.65; width:100%">
      Delete All Documents
    </button>
  </div>

</div><!-- /col-sidebar -->

<!-- ── Center: corpus library ── -->
<div class="col-corpus">
<div class="card corpus-card">

  <div class="corpus-toolbar">
    <div class="corpus-title-area">
      <h2 style="margin:0">Library</h2>
      <div class="doc-count" id="docCount"></div>
    </div>
    <div class="search-row">
      <input type="search" id="searchInput" placeholder="Search documents…">
      <button id="searchBtn" class="btn-sm">Search</button>
    </div>
  </div>

  <!-- Active filter indicator (hidden by default) -->
  <div class="filter-bar" id="filterBar" style="display:none">
    <span id="filterLabel"></span>
    <button class="clear-btn" onclick="clearFilter()" title="Clear filter">× clear</button>
  </div>

  <!-- Document list -->
  <ul class="doc-list" id="docList">
    <li style="padding:0.5rem 0; color:#ccc; font-size:0.88rem">Loading…</li>
  </ul>

</div>
</div><!-- /col-corpus -->

<!-- ── Right: document viewer ── -->
<div class="col-viewer">
<div class="card viewer-card">
  <div style="flex-shrink:0">
    <h2>Document</h2>
  </div>
  <div id="viewerContent">
    <p class="viewer-placeholder">Click a document title to read it here.</p>
  </div>
</div>
</div><!-- /col-viewer -->

</div><!-- /workspace -->

<script>
// ── Utilities ─────────────────────────────────────────────────────────────────

function escapeHtml(str) {
  return String(str ?? '')
    .replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}

function parseTags(raw) {
  try { return JSON.parse(raw || '[]'); } catch { return []; }
}

// ── State ─────────────────────────────────────────────────────────────────────

let activeTagFilter   = null;
let activeSearchQuery = null;
let currentDocId      = null;   // document currently open in the viewer
let currentDocContent = null;   // raw content string of that document

// ── File selection & upload ───────────────────────────────────────────────────

const dropZone   = document.getElementById('dropZone');
const fileInput  = document.getElementById('fileInput');
const fileNameEl = document.getElementById('fileName');
let selectedFiles = [];

function isAllowed(name) { return name.endsWith('.md') || name.endsWith('.txt'); }

async function readFilesFromEntry(entry, out = []) {
  if (entry.isFile) {
    if (isAllowed(entry.name))
      await new Promise((res, rej) => entry.file(f => { out.push(f); res(); }, rej));
  } else if (entry.isDirectory) {
    const reader = entry.createReader();
    let batch;
    do {
      batch = await new Promise((res, rej) => reader.readEntries(res, rej));
      for (const e of batch) await readFilesFromEntry(e, out);
    } while (batch.length > 0);
  }
  return out;
}

dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', async e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  const items = [...(e.dataTransfer?.items ?? [])];
  const files = [];
  for (const item of items) {
    const entry = item.webkitGetAsEntry?.();
    if (entry) await readFilesFromEntry(entry, files);
  }
  if (files.length) { selectedFiles = files; updateFileName(); }
});
fileInput.addEventListener('change', () => {
  selectedFiles = [...fileInput.files].filter(f => isAllowed(f.name));
  updateFileName();
});

function updateFileName() {
  fileNameEl.textContent = !selectedFiles.length ? '' :
    selectedFiles.length === 1 ? selectedFiles[0].name :
    `${selectedFiles.length} files selected`;
}

document.getElementById('uploadForm').addEventListener('submit', async e => {
  e.preventDefault();
  const btn    = document.getElementById('submitBtn');
  const status = document.getElementById('uploadStatus');
  const files  = selectedFiles.length ? selectedFiles
    : [...(fileInput.files ?? [])].filter(f => isAllowed(f.name));

  if (!files.length) {
    status.innerHTML = '<span class="error">✗ No .md or .txt files selected.</span>';
    return;
  }

  btn.disabled = true; btn.textContent = 'Uploading…'; status.textContent = '';

  const form = new FormData(document.getElementById('uploadForm'));
  form.delete('files');
  for (const f of files) form.append('files', f);
  const tagsRaw = form.get('tags');
  if (tagsRaw) form.set('tags',
    JSON.stringify(String(tagsRaw).split(',').map(t => t.trim()).filter(Boolean)));

  try {
    const res  = await fetch('/api/upload', { method: 'POST', body: form });
    const data = await res.json();
    if (res.ok) {
      const count   = Array.isArray(data) ? data.length : 1;
      const hlCount = Array.isArray(data)
        ? data.reduce((s, d) => s + (d.inline_annotations || 0), 0)
        : (data.inline_annotations || 0);
      const hlNote  = hlCount ? ` · ${hlCount} note${hlCount !== 1 ? 's' : ''} extracted` : '';
      status.innerHTML =
        `<span class="success">✓ ${count} document${count > 1 ? 's' : ''} added${hlNote}.</span>`;
      document.getElementById('uploadForm').reset();
      fileNameEl.textContent = ''; selectedFiles = [];
      refreshCorpus();
    } else { throw new Error(data.error || 'Upload failed'); }
  } catch (err) {
    status.innerHTML = `<span class="error">✗ ${escapeHtml(err.message)}</span>`;
  } finally { btn.disabled = false; btn.textContent = 'Upload'; }
});

// ── Corpus view ───────────────────────────────────────────────────────────────

async function refreshCorpus() {
  await Promise.all([loadDocuments(), loadTagSummary()]);
}

async function loadDocuments() {
  const list = document.getElementById('docList');
  list.innerHTML = '<li style="padding:0.5rem 0; color:#ccc; font-size:0.88rem">Loading…</li>';
  try {
    if (activeSearchQuery) { await loadSearchResults(activeSearchQuery); return; }

    const res  = await fetch('/api/documents');
    let docs   = await res.json();

    if (activeTagFilter) {
      docs = docs.filter(doc => parseTags(doc.tags).includes(activeTagFilter));
    }

    renderDocList(docs, false);
  } catch (err) {
    list.innerHTML =
      `<li class="error" style="padding:0.5rem 0">Failed to load: ${escapeHtml(err.message)}</li>`;
  }
}

async function loadSearchResults(query) {
  const list = document.getElementById('docList');
  try {
    const res  = await fetch('/api/search?q=' + encodeURIComponent(query));
    const rows = await res.json();
    renderDocList(rows, true);
  } catch (err) {
    list.innerHTML =
      `<li class="error" style="padding:0.5rem 0">Search failed: ${escapeHtml(err.message)}</li>`;
  }
}

function renderSnippet(raw) {
  return escapeHtml(raw || '').replace(/\*\*(.+?)\*\*/g, '<mark>$1</mark>');
}

function renderDocList(docs, hasSnippets) {
  const list    = document.getElementById('docList');
  const countEl = document.getElementById('docCount');

  if (!docs.length) {
    const msg = activeSearchQuery ? 'No documents match your search.'
      : activeTagFilter ? `No documents tagged #${escapeHtml(activeTagFilter)}.`
      : 'Upload documents to get started.';
    countEl.textContent = activeSearchQuery ? 'No results'
      : activeTagFilter ? 'No matches' : 'Empty';
    list.innerHTML =
      `<li style="padding:1.5rem 0; color:#ccc; font-size:0.88rem; text-align:center">${msg}</li>`;
    return;
  }

  countEl.textContent = `${docs.length} document${docs.length !== 1 ? 's' : ''}`;
  list.innerHTML = docs.map(doc => renderDocCard(doc, hasSnippets ? doc.snippet : null)).join('');
}

function renderDocCard(doc, snippet) {
  const tags    = parseTags(doc.tags);
  const docId   = doc.id;

  const tagChips = tags.map(tag => `
    <span class="tag-chip" data-tag="${escapeHtml(tag)}" data-doc-id="${docId}">
      <span class="tag-chip-label">#${escapeHtml(tag)}</span>
      <button class="tag-remove" data-remove-tag="${escapeHtml(tag)}"
              data-doc-id="${docId}" title="Remove tag">×</button>
    </span>`).join('');

  const snippetHtml = snippet
    ? `<div class="doc-snippet">${renderSnippet(snippet)}</div>` : '';

  return `
    <li class="doc-card" id="doc-${docId}" data-doc-id="${docId}">
      <div class="doc-main" data-view-doc="${docId}">
        <div class="doc-title">${escapeHtml(doc.title || 'Untitled')}</div>
        <div class="doc-meta">${escapeHtml(doc.author || '—')} · ${escapeHtml(doc.publication_date || '?')}</div>
        ${snippetHtml}
      </div>
      <div class="doc-tags">
        ${tagChips}
        <button class="btn-add-tag" data-show-tag-input="${docId}">+ tag</button>
        <input class="tag-input-inline" id="tag-input-${docId}"
               placeholder="type tag, press Enter" style="display:none"
               data-doc-id="${docId}">
        <button class="tag-confirm-btn" id="tag-save-${docId}"
                style="display:none" data-confirm-tag="${docId}">✓</button>
        <button class="tag-cancel-btn" id="tag-cancel-${docId}"
                style="display:none" data-cancel-tag="${docId}">✕</button>
      </div>
      <button class="btn-doc-delete" data-delete-doc="${docId}" title="Delete document">✕</button>
    </li>`;
}

// ── Event delegation on doc list ──────────────────────────────────────────────

document.getElementById('docList').addEventListener('click', async e => {
  // Remove a tag chip (× button)
  const removeBtn = e.target.closest('[data-remove-tag]');
  if (removeBtn) {
    e.stopPropagation();
    await removeTag(removeBtn.dataset.docId, removeBtn.dataset.removeTag);
    return;
  }

  // Click tag chip label → browse by tag
  const tagChip = e.target.closest('.tag-chip');
  if (tagChip && !e.target.closest('[data-remove-tag]')) {
    browseTag(tagChip.dataset.tag);
    return;
  }

  // Click doc title/meta → view document
  const viewEl = e.target.closest('[data-view-doc]');
  if (viewEl) { viewDocument(viewEl.dataset.viewDoc); return; }

  // Show tag input
  const addTagBtn = e.target.closest('[data-show-tag-input]');
  if (addTagBtn) { showTagInput(addTagBtn.dataset.showTagInput); return; }

  // Confirm new tag
  const confirmBtn = e.target.closest('[data-confirm-tag]');
  if (confirmBtn) { await commitTag(confirmBtn.dataset.confirmTag); return; }

  // Cancel tag input
  const cancelBtn = e.target.closest('[data-cancel-tag]');
  if (cancelBtn) { hideTagInput(cancelBtn.dataset.cancelTag); return; }

  // Delete document
  const deleteBtn = e.target.closest('[data-delete-doc]');
  if (deleteBtn) { await deleteDoc(deleteBtn.dataset.deleteDoc); return; }
});

document.getElementById('docList').addEventListener('keydown', e => {
  const input = e.target.closest('.tag-input-inline');
  if (!input) return;
  const docId = input.dataset.docId;
  if (e.key === 'Enter') { e.preventDefault(); commitTag(docId); }
  if (e.key === 'Escape') hideTagInput(docId);
});

// ── Tag editing ───────────────────────────────────────────────────────────────

function showTagInput(docId) {
  const input      = document.getElementById('tag-input-' + docId);
  const saveBtn    = document.getElementById('tag-save-' + docId);
  const cancelBtn  = document.getElementById('tag-cancel-' + docId);
  const addTagBtn  = document.querySelector(`[data-show-tag-input="${docId}"]`);
  if (!input) return;
  if (addTagBtn)  addTagBtn.style.display  = 'none';
  input.style.display    = 'inline-block';
  saveBtn.style.display  = 'inline-block';
  cancelBtn.style.display = 'inline-block';
  input.focus();
}

function hideTagInput(docId) {
  const input     = document.getElementById('tag-input-' + docId);
  const saveBtn   = document.getElementById('tag-save-' + docId);
  const cancelBtn = document.getElementById('tag-cancel-' + docId);
  const addTagBtn = document.querySelector(`[data-show-tag-input="${docId}"]`);
  if (!input) return;
  input.value = ''; input.style.display = 'none';
  if (saveBtn)   saveBtn.style.display   = 'none';
  if (cancelBtn) cancelBtn.style.display = 'none';
  if (addTagBtn) addTagBtn.style.display = '';
}

async function commitTag(docId) {
  const input = document.getElementById('tag-input-' + docId);
  if (!input) return;
  const raw = input.value.trim();
  if (!raw) { hideTagInput(docId); return; }
  // Normalise: lowercase, spaces → hyphens
  const tag = raw.toLowerCase().replace(/\s+/g, '-');
  hideTagInput(docId);
  await addTag(docId, tag);
}

async function addTag(docId, tag) {
  try {
    const doc  = await fetch('/api/documents/' + docId).then(r => r.json());
    const tags = parseTags(doc.tags);
    if (tags.includes(tag)) return;
    await updateDocTags(docId, [...tags, tag]);
  } catch (err) { alert('Could not add tag: ' + err.message); }
}

async function removeTag(docId, tag) {
  try {
    const doc  = await fetch('/api/documents/' + docId).then(r => r.json());
    const tags = parseTags(doc.tags).filter(t => t !== tag);
    await updateDocTags(docId, tags);          // patches + refreshCorpus()

    // Delete orphaned inline annotations for the removed tag
    const anns = await fetch('/api/documents/' + docId + '/annotations').then(r => r.json());
    const orphans = anns.filter(a => a.tag === tag && a.author_id === 'inline');
    await Promise.all(orphans.map(a =>
      fetch('/api/annotations/' + a.id, { method: 'DELETE' })
    ));
    if (orphans.length > 0 && currentDocId === docId) {
      await viewDocument(docId);               // re-render viewer without ghost highlights
    }
  } catch (err) { alert('Could not remove tag: ' + err.message); }
}

async function updateDocTags(docId, tags) {
  const r = await fetch('/api/documents/' + docId, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ tags }),
  });
  if (!r.ok) { const e = await r.json(); throw new Error(e.error || 'Update failed'); }
  await refreshCorpus();
}

// ── Search ────────────────────────────────────────────────────────────────────

async function doSearch() {
  const q = document.getElementById('searchInput').value.trim();
  if (!q) { clearFilter(); return; }
  activeSearchQuery = q;
  activeTagFilter   = null;
  updateFilterBar();
  await loadDocuments();
}

function clearFilter() {
  activeSearchQuery = null;
  activeTagFilter   = null;
  document.getElementById('searchInput').value = '';
  updateFilterBar();
  loadDocuments();
  loadTagSummary();
}

function updateFilterBar() {
  const bar   = document.getElementById('filterBar');
  const label = document.getElementById('filterLabel');
  if (activeSearchQuery) {
    bar.style.display   = '';
    label.textContent   = `Search: "${activeSearchQuery}"`;
  } else if (activeTagFilter) {
    bar.style.display   = '';
    label.textContent   = `Tag: #${activeTagFilter}`;
  } else {
    bar.style.display   = 'none';
    label.textContent   = '';
  }
}

document.getElementById('searchBtn').addEventListener('click', doSearch);
document.getElementById('searchInput').addEventListener('keydown', e => {
  if (e.key === 'Enter') doSearch();
  if (e.key === 'Escape') clearFilter();
});

// ── Tag browser (sidebar) ─────────────────────────────────────────────────────

async function loadTagSummary() {
  const container = document.getElementById('tagList');
  try {
    const tags = await fetch('/api/tags/summary').then(r => r.json());
    if (!tags.length) {
      container.innerHTML =
        '<span style="color:#ccc; font-size:0.83rem; line-height:1.6">' +
        'No tags yet. Add tags to your documents to see them here.</span>';
      return;
    }
    const maxScore = Math.max(...tags.map(t => t.doc_count + t.highlight_count), 1);
    container.innerHTML = tags.map(t => {
      const isActive   = activeTagFilter === t.tag;
      const pct        = Math.max(4, Math.round((t.doc_count + t.highlight_count) / maxScore * 100));
      const countLabel = t.doc_count ? `${t.doc_count} doc${t.doc_count !== 1 ? 's' : ''}` : '';
      return `
        <div class="tag-bar${isActive ? ' active' : ''}" data-browse-tag="${escapeHtml(t.tag)}">
          <span class="tag-bar-label">#${escapeHtml(t.tag)}</span>
          <div class="tag-bar-track"><div class="tag-bar-fill" style="width:${pct}%"></div></div>
          <span class="tag-bar-count">${countLabel}</span>
        </div>`;
    }).join('');
  } catch {
    container.innerHTML = '<span class="error" style="font-size:0.82rem">Failed to load tags.</span>';
  }
}

document.getElementById('tagList').addEventListener('click', e => {
  const bar = e.target.closest('[data-browse-tag]');
  if (bar) browseTag(bar.dataset.browseTag);
});

function browseTag(tag) {
  activeTagFilter   = tag;
  activeSearchQuery = null;
  document.getElementById('searchInput').value = '';
  updateFilterBar();
  loadDocuments();
  loadTagSummary();
}

// ── Document viewer ───────────────────────────────────────────────────────────

function renderInlineMarkup(rawContent) {
  let html = escapeHtml(rawContent);
  html = html.replace(/==([^=\n]+?)==/g, (_, text) =>
    `<mark class="inline-hl">${text}</mark>`);
  html = html.replace(/#([a-zA-Z][\w-]*)/g, (_, tag) =>
    `<span style="color:#5c6bc0; cursor:pointer; font-weight:500"
           onclick="browseTag('${escapeHtml(tag)}')">#${tag}</span>`);
  return html;
}

// Deterministic pastel colour per tag name
function tagColor(tag) {
  if (!tag) return 'hsla(48,100%,72%,0.55)';
  let h = 0;
  for (let i = 0; i < tag.length; i++) { h = ((h << 5) - h) + tag.charCodeAt(i); h |= 0; }
  return `hsla(${Math.abs(h) % 360},68%,72%,0.55)`;
}

// Render document content overlaying DB annotation highlights
function renderWithAnnotations(rawContent, annotations) {
  if (!annotations || !annotations.length) return renderInlineMarkup(rawContent);

  // Find all occurrences of each source_passage in the raw text
  const ranges = [];
  for (const ann of annotations) {
    if (!ann.source_passage) continue;
    let idx = rawContent.indexOf(ann.source_passage);
    while (idx !== -1) {
      ranges.push({ start: idx, end: idx + ann.source_passage.length, ann });
      idx = rawContent.indexOf(ann.source_passage, idx + 1);
    }
  }
  if (!ranges.length) return renderInlineMarkup(rawContent);

  ranges.sort((a, b) => a.start - b.start);

  let html = '', cursor = 0;
  for (const r of ranges) {
    if (r.start < cursor) continue;                     // skip overlapping ranges
    if (r.start > cursor)
      html += renderInlineMarkup(rawContent.slice(cursor, r.start));
    const bg  = tagColor(r.ann.tag);
    const tip = escapeHtml('#' + (r.ann.tag || 'note') +
      (r.ann.text && r.ann.text !== r.ann.source_passage ? ' · ' + r.ann.text : ''));
    html += `<mark class="ann-hl" style="background:${bg}" title="${tip}">`
          + renderInlineMarkup(rawContent.slice(r.start, r.end))
          + '</mark>';
    cursor = r.end;
  }
  if (cursor < rawContent.length) html += renderInlineMarkup(rawContent.slice(cursor));
  return html;
}

// Annotation list rendered below the document body
function renderAnnotationList(anns) {
  if (!anns.length) return '';
  return `
    <div class="ann-list">
      <div class="ann-list-title">${anns.length} annotation${anns.length !== 1 ? 's' : ''}</div>
      ${anns.map(a => {
        const bg      = tagColor(a.tag);
        const solid   = bg.replace('0.55)', '1)');
        const passage = a.source_passage || '';
        const note    = (a.text && a.text !== a.source_passage) ? a.text : '';
        return `
          <div class="ann-item" style="border-left:3px solid ${solid}">
            ${a.tag ? `<span class="ann-item-tag" style="background:${bg}">#${escapeHtml(a.tag)}</span>` : ''}
            ${passage ? `<div class="ann-item-passage">&ldquo;${escapeHtml(passage)}&rdquo;</div>` : ''}
            ${note    ? `<div class="ann-item-note">${escapeHtml(note)}</div>` : ''}
          </div>`;
      }).join('')}
    </div>`;
}

async function viewDocument(docId) {
  currentDocId = docId;
  const panel  = document.getElementById('viewerContent');
  panel.innerHTML = '<span style="color:#ccc; font-size:0.88rem">Loading…</span>';
  try {
    const [doc, anns] = await Promise.all([
      fetch('/api/documents/' + docId).then(r => r.json()),
      fetch('/api/documents/' + docId + '/annotations').then(r => r.json()).catch(() => []),
    ]);
    currentDocContent = doc.content || '';

    const meta    = [doc.author, doc.publication_date].filter(Boolean).join(' · ');
    // Only use annotations with a source_passage (created by selection tool)
    const selAnns = anns.filter(a => a.source_passage && a.author_type === 'human');
    const count   = selAnns.length;

    const header = `
      <div class="viewer-doc-header">
        <strong style="font-size:0.95rem">${escapeHtml(doc.title || 'Untitled')}</strong>
        ${meta ? `<div style="font-size:0.8rem; color:#aaa; margin-top:0.2rem">${escapeHtml(meta)}</div>` : ''}
        ${count ? `<div style="font-size:0.75rem; color:#7986cb; margin-top:0.2rem">${count} annotation${count !== 1 ? 's' : ''}</div>` : ''}
      </div>`;
    const body = renderWithAnnotations(currentDocContent, selAnns);
    panel.innerHTML = header + `<div class="viewer-body">${body}</div>` + renderAnnotationList(selAnns);
  } catch {
    panel.innerHTML = '<span class="error">Failed to load document.</span>';
  }
}

// ── Text-selection annotation toolbar ────────────────────────────────────────

let mouseDownOnToolbar = false;

document.addEventListener('mousedown', e => {
  mouseDownOnToolbar = !!e.target.closest('#ann-toolbar');
});

document.getElementById('viewerContent').addEventListener('mouseup', (e) => {
  if (mouseDownOnToolbar) return;
  const mouseX = e.clientX;
  const mouseY = e.clientY;
  setTimeout(() => {
    const sel = window.getSelection();
    if (!sel || sel.isCollapsed || !currentDocId) { hideAnnotationToolbar(); return; }
    const text = sel.toString().trim();
    if (text.length < 2) { hideAnnotationToolbar(); return; }
    const range = sel.getRangeAt(0);
    if (!document.getElementById('viewerContent').contains(range.commonAncestorContainer)) {
      hideAnnotationToolbar(); return;
    }
    // getBoundingClientRect() can return a zero rect in some browsers when called
    // inside a setTimeout; fall back to the mouse-release coordinates in that case.
    let selRect = range.getBoundingClientRect();
    if (!selRect.width && !selRect.height)
      selRect = { top: mouseY, bottom: mouseY, left: mouseX, right: mouseX, width: 0, height: 0 };
    showAnnotationToolbar(selRect, text);
  }, 10);
});

function showAnnotationToolbar(selRect, selectedText) {
  hideAnnotationToolbar();

  const toolbar = document.createElement('div');
  toolbar.id = 'ann-toolbar';
  toolbar.innerHTML = `
    <span class="ann-toolbar-label">Tag</span>
    <input id="ann-tag-input" type="text" placeholder="e.g. sublime"
           style="width:100px; padding:0.25rem 0.45rem; border:1px solid #c5cae9;
                  border-radius:5px; font-size:0.82rem; font-family:inherit; outline:none">
    <span class="ann-toolbar-label" style="color:#ccc">Note</span>
    <input id="ann-note-input" type="text" placeholder="optional"
           style="width:140px; padding:0.25rem 0.45rem; border:1px solid #e0e0e0;
                  border-radius:5px; font-size:0.82rem; font-family:inherit; outline:none">
    <button id="ann-save-btn"
            style="background:#5c6bc0; color:white; border:none; border-radius:5px;
                   padding:0.28rem 0.8rem; font-size:0.82rem; cursor:pointer; font-family:inherit">
      Annotate
    </button>
    <button id="ann-cancel-btn"
            style="background:none; border:none; color:#ccc; cursor:pointer;
                   font-size:1.1rem; line-height:1; padding:0 0.1rem">✕</button>`;

  // Insert hidden to measure actual dimensions, then position
  toolbar.style.visibility = 'hidden';
  document.body.appendChild(toolbar);
  const { width: tw, height: th } = toolbar.getBoundingClientRect();
  toolbar.style.visibility = '';

  // Position: above the selection, centred, clamped to viewport
  let top  = selRect.top  - th - 8;
  let left = selRect.left + selRect.width / 2 - tw / 2;
  if (top < 8) top = selRect.bottom + 8;
  left = Math.max(8, Math.min(left, window.innerWidth - tw - 8));
  toolbar.style.cssText += `position:fixed; top:${top}px; left:${left}px;`;

  document.getElementById('ann-tag-input').focus();

  const doSave = async () => {
    const tag  = document.getElementById('ann-tag-input').value.trim();
    const note = document.getElementById('ann-note-input').value.trim();
    if (!tag) {
      document.getElementById('ann-tag-input').style.borderColor = '#e53935';
      document.getElementById('ann-tag-input').focus();
      return;
    }
    hideAnnotationToolbar();
    window.getSelection()?.removeAllRanges();
    await saveAnnotation(selectedText, tag.toLowerCase().replace(/\s+/g, '-'), note);
  };

  document.getElementById('ann-save-btn').addEventListener('click', doSave);
  document.getElementById('ann-cancel-btn').addEventListener('click', () => {
    hideAnnotationToolbar(); window.getSelection()?.removeAllRanges();
  });
  for (const inputId of ['ann-tag-input', 'ann-note-input']) {
    document.getElementById(inputId).addEventListener('keydown', e => {
      if (e.key === 'Enter')  { e.preventDefault(); doSave(); }
      if (e.key === 'Tab' && inputId === 'ann-tag-input')
        { e.preventDefault(); document.getElementById('ann-note-input').focus(); }
      if (e.key === 'Escape') { hideAnnotationToolbar(); window.getSelection()?.removeAllRanges(); }
    });
  }
}

function hideAnnotationToolbar() {
  document.getElementById('ann-toolbar')?.remove();
}

async function saveAnnotation(sourcePassage, tag, note) {
  if (!currentDocId) return;
  const startOffset = currentDocContent ? currentDocContent.indexOf(sourcePassage) : -1;
  const endOffset   = startOffset >= 0 ? startOffset + sourcePassage.length : -1;
  try {
    const r = await fetch('/api/documents/' + currentDocId + '/annotations', {
      method:  'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        source_passage: sourcePassage,
        text:           note || null,
        tag,
        author_id:      'researcher',
        start_offset:   startOffset >= 0 ? startOffset : null,
        end_offset:     endOffset   >= 0 ? endOffset   : null,
      }),
    });
    if (!r.ok) throw new Error((await r.json()).error || 'Save failed');
    await viewDocument(currentDocId);   // refresh viewer with new highlight
    loadTagSummary();                   // new tag may have appeared in sidebar
    refreshCorpus();                    // update doc card in centre column
  } catch (err) {
    alert('Could not save annotation: ' + err.message);
  }
}

// ── Delete ────────────────────────────────────────────────────────────────────

async function deleteDoc(id) {
  if (!confirm('Delete this document from the corpus? This cannot be undone.')) return;
  await fetch(`/api/documents/${id}`, { method: 'DELETE' });
  refreshCorpus();
}


document.getElementById('exportBtn').addEventListener('click', async () => {
  const r = await fetch('/api/documents');
  const docs = await r.json();
  if (!docs.length) { alert('Nothing to export — corpus is empty.'); return; }
  window.location.href = '/api/export';
});

document.getElementById('deleteAllBtn').addEventListener('click', async () => {
  const res   = await fetch('/api/documents');
  const docs  = await res.json();
  const count = docs.length;
  if (!count) { alert('The corpus is already empty.'); return; }
  if (!confirm(
    `Delete all ${count} document${count > 1 ? 's' : ''} and their notes?\nThis cannot be undone.`
  )) return;
  const typed = prompt('Type DELETE to confirm:');
  if ((typed ?? '').toUpperCase() !== 'DELETE') return;
  try {
    const r = await fetch('/api/corpus', { method: 'DELETE' });
    if (!r.ok) {
      const body = await r.text();
      let msg = `HTTP ${r.status}`;
      try { msg = JSON.parse(body).error || msg; } catch { msg = body || msg; }
      throw new Error(msg);
    }
    refreshCorpus();
  } catch (err) { alert('Delete failed: ' + err.message); }
});

// ── Supabase sync ─────────────────────────────────────────────────────────────

async function pollSyncStatus() {
  try {
    const s   = await fetch('/api/sync/status').then(r => r.json());
    const el  = document.getElementById('syncStatusBadge');
    const btn = document.getElementById('syncBtn');
    if (!s.configured) { el.textContent = ''; btn.style.display = 'none'; return; }
    btn.style.display = '';
    const dirty = (s.dirty_documents || 0) + (s.dirty_annotations || 0);
    if (dirty > 0) { el.textContent = `${dirty} unsynced`; el.style.color = '#e65100'; }
    else {
      const lastRaw = s.last_synced_documents || s.last_synced_annotations;
      el.textContent = lastRaw ? `Synced ${new Date(lastRaw).toLocaleTimeString()}` : 'Not synced';
      el.style.color = '#2e7d32';
    }
  } catch { /* ignore */ }
}

async function triggerSync() {
  const btn = document.getElementById('syncBtn');
  const el  = document.getElementById('syncStatusBadge');
  btn.disabled = true; btn.textContent = 'Syncing…';
  el.textContent = 'Syncing…'; el.style.color = '#5c6bc0';
  try {
    const r    = await fetch('/api/sync', { method: 'POST' });
    const data = await r.json();
    if (!r.ok) throw new Error(data.error);
    await pollSyncStatus();
    loadDocuments();
  } catch (err) {
    el.textContent = '✗ Sync failed'; el.style.color = '#c62828';
    alert('Sync failed: ' + err.message);
  } finally { btn.disabled = false; btn.textContent = '↑↓ Sync'; }
}

setInterval(pollSyncStatus, 10000);

// ── Collapsible card arrows ───────────────────────────────────────────────────

document.querySelectorAll('details.card').forEach(d => {
  d.addEventListener('toggle', function () {
    const arrow = this.querySelector('.arrow');
    if (arrow) arrow.textContent = this.open ? '▾' : '▸';
  });
});

// ── Boot ──────────────────────────────────────────────────────────────────────

loadDocuments();
loadTagSummary();
pollSyncStatus();

</script>
</body>
</html>
